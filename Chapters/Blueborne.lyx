#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass classicthesis
\use_default_options true
\maintain_unincluded_children false
\language italian
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine natbib
\cite_engine_type numerical
\biblio_style plainnat
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 2
\tocdepth 2
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begingroup
\end_layout

\begin_layout Plain Layout


\backslash
let
\backslash
clearpage
\backslash
relax
\end_layout

\begin_layout Plain Layout


\backslash
let
\backslash
cleardoublepage
\backslash
relax
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align right
\begin_inset Graphics
	filename /home/mrnfrancesco/git/master-thesis/gfx/blueborne-logo.png
	display false
	width 2.5cm

\end_inset


\end_layout

\begin_layout Chapter
BlueBorne
\begin_inset CommandInset label
LatexCommand label
name "ch:blueborne"

\end_inset


\end_layout

\begin_layout Section
Android Information Leak (CVE-2017-0785)
\end_layout

\begin_layout Standard
\begin_inset CommandInset citation
LatexCommand nocite
key "blueborne_white_paper"

\end_inset


\end_layout

\begin_layout Standard
La struttura del 
\emph on
Continuation State
\emph default
 utilizzata nell'implementazione Android dello stack Bluetooth è la seguente:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language={C++},showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout

typedef struct { 
\end_layout

\begin_layout Plain Layout

	uint16_t cont_offset;
\end_layout

\begin_layout Plain Layout

} sdp_cont_state_t;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In questo caso la struttura presenta solamente un offset di 
\begin_inset Formula $16$
\end_inset

 bit che indica quale frammento inviare alla prossima richiesta.
\end_layout

\begin_layout Standard
La funzione che gestisce tutte le richieste SDP si trova in 
\begin_inset CommandInset href
LatexCommand href
name "/stack/sdp/sdp_server.c"
target "https://android.googlesource.com/platform/system/bt/+/android-7.1.1_r44/stack/sdp/sdp_server.c#117"

\end_inset

 ed ha la seguente firma:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline false
status open

\begin_layout Plain Layout

void sdp_server_handle_client_req (
\end_layout

\begin_layout Plain Layout

	tCONN_CB * p_ccb,
\end_layout

\begin_layout Plain Layout

	BT_HDR * p_msg
\end_layout

\begin_layout Plain Layout

);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Come indicato nella documentazione, la funzione riceve tutti i dati derivanti
 dal livello L2CAP e li passa alla funzione appropriata per la gestione.
 Un estratto del codice è il seguente:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline false
status open

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

/* The first byte in the message is the pdu type */
\end_layout

\begin_layout Plain Layout

pdu_id = *p_req++;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Extract the transaction number and parameter length */
\end_layout

\begin_layout Plain Layout

BE_STREAM_TO_UINT16(trans_num, p_req);
\end_layout

\begin_layout Plain Layout

BE_STREAM_TO_UINT16(param_len, p_req);
\end_layout

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

switch (pdu_id) {
\end_layout

\begin_layout Plain Layout

	case SDP_PDU_SERVICE_SEARCH_REQ:
\end_layout

\begin_layout Plain Layout

		process_service_search(p_ccb, trans_num, param_len, p_req, p_req_end);
\end_layout

\begin_layout Plain Layout

		break;
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Proseguendo nell'albero delle chiamate andiamo ad analizzare la funzione
 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

process_service_search
\end_layout

\end_inset

 che si occupa di gestire le 
\emph on
service search request
\emph default
 spiegate nella sezione 
\begin_inset CommandInset ref
LatexCommand nameref
reference "subsec:sdp-service-search"

\end_inset

 
\begin_inset CommandInset ref
LatexCommand vpageref
reference "subsec:sdp-service-search"

\end_inset

.
\end_layout

\begin_layout Standard
La funzione si trova anch'essa in 
\begin_inset CommandInset href
LatexCommand href
name "/stack/sdp/sdp_server.c"
target "https://android.googlesource.com/platform/system/bt/+/android-7.1.1_r44/stack/sdp/sdp_server.c#176"

\end_inset

 con la seguente firma:
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline false
status open

\begin_layout Plain Layout

static void process_service_search(
\end_layout

\begin_layout Plain Layout

	tCONN_CB* p_ccb,
\end_layout

\begin_layout Plain Layout

	uint16_t trans_num,
\end_layout

\begin_layout Plain Layout

	uint16_t param_len,
\end_layout

\begin_layout Plain Layout

	uint8_t* p_req,
\end_layout

\begin_layout Plain Layout

	UNUSED_ATTR uint8_t* p_req_end
\end_layout

\begin_layout Plain Layout

);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Andando ad analizzare la sua implementazione poniamo la nostra attenzione
 sul seguente estratto:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language={C++},showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout

uint16_t cur_handles, rem_handles, cont_offset, num_rsp_handles;
\end_layout

\begin_layout Plain Layout

uint32_t rsp_handles[SDP_MAX_RECORDS] = {0};
\end_layout

\begin_layout Plain Layout

tSDP_RECORD* p_rec = NULL;
\end_layout

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

/* Get a list of handles that match the UUIDs given to us */
\end_layout

\begin_layout Plain Layout

for (num_rsp_handles = 0; num_rsp_handles < max_replies;) {
\end_layout

\begin_layout Plain Layout

	p_rec = sdp_db_service_search(p_rec, &uid_seq);
\end_layout

\begin_layout Plain Layout

	if (p_rec)
\end_layout

\begin_layout Plain Layout

		rsp_handles[num_rsp_handles++] = p_rec->record_handle;
\end_layout

\begin_layout Plain Layout

	else
\end_layout

\begin_layout Plain Layout

		break;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

/* Check if this is a continuation request */
\end_layout

\begin_layout Plain Layout

if (*p_req) {
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

	if (cont_offset != p_ccb->cont_offset) {
\end_layout

\begin_layout Plain Layout

		sdpu_build_n_send_error(
\end_layout

\begin_layout Plain Layout

			p_ccb,
\end_layout

\begin_layout Plain Layout

			trans_num,
\end_layout

\begin_layout Plain Layout

			SDP_INVALID_CONT_STATE,
\end_layout

\begin_layout Plain Layout

			SDP_TEXT_BAD_CONT_INX
\end_layout

\begin_layout Plain Layout

		);
\end_layout

\begin_layout Plain Layout

		return;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	/* extract the remaining handles */
\end_layout

\begin_layout Plain Layout

	rem_handles = num_rsp_handles - cont_offset;
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

/* Calculate how many handles will fit in one PDU */
\end_layout

\begin_layout Plain Layout

cur_handles =
\end_layout

\begin_layout Plain Layout

	(uint16_t)((pccb->rem_mtu_size - SDP_MAX_SERVICE_RSPHDR_LEN) / 4);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if (rem_handles <= cur_handles)
\end_layout

\begin_layout Plain Layout

	cur_handles = rem_handles;
\end_layout

\begin_layout Plain Layout

else { /* Continuation is set */
\end_layout

\begin_layout Plain Layout

	p_ccb->cont_offset += cur_handles;
\end_layout

\begin_layout Plain Layout

	is_cont = true;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

for (xx = cont_offset; xx < cont_offset + cur_handles; xx++)
\end_layout

\begin_layout Plain Layout

	UINT32_TO_BE_STREAM(p_rsp, rsp_handles[xx]);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Come si può notare il codice mantiene una copia del valore di 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

cont_offset
\end_layout

\end_inset

 (equivalente al 
\emph on
Continuation State Value
\emph default
) nell'oggetto 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

p_ccb
\end_layout

\end_inset

 che mantiene le informazioni di connessione, e controlla che il valore
 ricevuto sia uguale a quello atteso; se i due valori differiscono la funzione
 termina segnalando l'errore.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline false
status open

\begin_layout Plain Layout

if (cont_offset != p_ccb->cont_offset) {
\end_layout

\begin_layout Plain Layout

	sdpu_build_n_send_error(...);
\end_layout

\begin_layout Plain Layout

	return;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In questo scenario non è possibile abusare di un valore di 
\emph on
continuation state
\emph default
 malformato che permetta di leggere zone di memoria arbitrarie.
 Tuttavia, come già visto in Figura 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:sdp-continuation-state-workflow"

\end_inset

, per il recupero dell'intera risposta il meccanismo di frammentazione del
 livello SDP si aspetta che la richiesta fatta del client sia sempre la
 stessa, mentre a variare è il valore del 
\emph on
continuation state
\emph default
.
 Possiamo notare come l'estratto di codice della funzione 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

process_service_search
\end_layout

\end_inset

 non abbia alcun controllo sulla consistenza dei parametri di due o più
 richieste successive; possiamo quindi sfruttare questo per portare il codice
 in uno stato inconsistente.
\end_layout

\begin_layout Standard
Il numero di frammenti rimanenti da inviare al client non viene salvato
 nell'oggetto 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

p_ccb
\end_layout

\end_inset

 per essere validato alla ricezione di una nuova richiesta, ma è calcolato
 ad ogni invocazione della funzione eseguendo:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline false
status open

\begin_layout Plain Layout

rem_handles = num_rsp_handles - cont_offset;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
dove 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

num_rsp_handles
\end_layout

\end_inset

 rappresenta il numero totale di frammenti della risposta all'attuale richiesta
 SDP, mentre 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

cont_offset
\end_layout

\end_inset

, lo ricordiamo, è l'offset del frammento corrente da leggere.
\end_layout

\begin_layout Standard
La mancanza di questo controllo nasce dall'assunzione (errata) che due richieste
 successive facciano riferimento alla stessa risposta.
\end_layout

\begin_layout Standard
Se quindi potessimo sfruttare questa situazione per portare il valore di
 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

rem_handles
\end_layout

\end_inset

 ad essere maggiore del reale numero dei frammenti rimanenti tramite 
\emph on
underflow
\emph default

\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Si ha quando il risultato di un calcolo è un numero minore del valore minore
 rappresentabile.
 La conseguenza è quella di ottenere valori generalmente molto alti, vicini
 al massimo valore rappresentabile.
\end_layout

\end_inset

, durante il 
\emph on
loop
\emph default
 di lettura dei frammenti si andrebbero a leggere sequenze di byte nello
 stack oltre quelle consentite, che verrebbero restituite nella risposta
 SDP ottenendo così una vulnerabilità di tipo 
\emph on
Information Exposure
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Divulgazione intenzionale o non intenzionale di informazioni a un attore
 - che non è esplicitamente autorizzato ad avere accesso a quell'informazione
\end_layout

\end_inset


\emph default
 (
\begin_inset CommandInset href
LatexCommand href
name "CWE-200"
target "http://cwe.mitre.org/data/definitions/200.html"

\end_inset

).
\end_layout

\begin_layout Standard
Questo comportamento si può ottenere seguendo il flusso di richieste semplificat
o in Figura 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:sdp-malformed-continuation-state-workflow"

\end_inset

.
\end_layout

\begin_layout Standard
\align center
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{sequencediagram}
\end_layout

\begin_layout Plain Layout

	
\backslash
renewcommand
\backslash
unitfactor{0.75}
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	
\backslash
newthread{client}{SDP Client}
\end_layout

\begin_layout Plain Layout

	
\backslash
newinst[6]{server}{SDP Server}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	
\backslash
begin{call}{client}{
\backslash
small ServiceSearchRequest(UUID=
\backslash
(0
\backslash
)xDEAD)}{server}{
\backslash
small ServiceSearchResponse 
\backslash
((1/N)
\backslash
) + CS 
\backslash
((1)
\backslash
)}
\backslash
end{call}
\end_layout

\begin_layout Plain Layout

	
\backslash
begin{call}{client}{
\backslash
small ServiceSearchRequest(UUID=
\backslash
(0
\backslash
)xBEEF) + CS 
\backslash
((1)
\backslash
)}{server}{
\backslash
small ServiceSearchResponse 
\backslash
((2/N)
\backslash
) + CS 
\backslash
((2)
\backslash
)}
\backslash
end{call}
\end_layout

\begin_layout Plain Layout

	
\backslash
begin{call}{client}{
\backslash
dots}{server}{
\backslash
dots}
\backslash
end{call}
\end_layout

\begin_layout Plain Layout

	
\backslash
begin{call}{client}{
\backslash
small ServiceSearchRequest(UUID=
\backslash
(0
\backslash
)xBEEF) + CS 
\backslash
((i)
\backslash
)}{server}{
\backslash
small ServiceSearchResponse 
\backslash
((2/N)
\backslash
) + CS 
\backslash
((2)
\backslash
)}
\backslash
end{call}
\end_layout

\begin_layout Plain Layout

	
\backslash
begin{call}{client}{
\backslash
dots}{server}{
\backslash
dots}
\backslash
end{call}
\end_layout

\begin_layout Plain Layout

	
\backslash
begin{call}{client}{
\backslash
small ServiceSearchRequest(UUID=
\backslash
(0
\backslash
)xBEEF) + CS 
\backslash
((N)
\backslash
)}{server}{
\backslash
small ServiceSearchResponse 
\backslash
((N/N)
\backslash
)}
\backslash
end{call}
\end_layout

\begin_layout Plain Layout


\backslash
end{sequencediagram}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:sdp-malformed-continuation-state-workflow"

\end_inset

Workflow malformato di una comunicazione SDP con 
\emph on
continuation state
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Quello che permette l'
\emph on
underflow
\emph default
 è in particolare la scelta dei due servizi da interrogare.
 Più in dettaglio i passi da seguire sono:
\end_layout

\begin_layout Enumerate
Il client (attaccante) effettuata una richiesta SDP per un servizio con
 
\begin_inset Formula $\text{UUID}=0\text{xDEAD}$
\end_inset

.
\end_layout

\begin_layout Enumerate
Il server riceve la richiesta e genera una risposta contenente un 
\emph on
continuation state
\emph default
.
 La dimensione di questa risposta è definita dal valore di 
\begin_inset Flex CT - acronym
status collapsed

\begin_layout Plain Layout

MTU
\end_layout

\end_inset

 impostato dal client durante la connessione; in questo modo l'attaccante
 può controllare la dimensione dei frammenti restituiti.
\end_layout

\begin_layout Enumerate
Il client effettua una seconda richiesta SDP per un servizio con 
\begin_inset Formula $\text{UUID}=0\text{xBEEF}$
\end_inset

 apponendo alla richiesta il 
\emph on
continuation state
\emph default
 ricevuto dalla risposta precedente riferita al servizio con 
\begin_inset Formula $\text{UUID}=0\text{xDEAD}$
\end_inset

.
 Nella scelta dei due UUID è importante che il servizio interrogato per
 primo restituisca un numero di risposte superiore a quelle restituite dal
 secondo servizio scelto.
\end_layout

\begin_layout Enumerate
Il server riceve la richiesta ed effettua la validazione del campo 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

cont_offset
\end_layout

\end_inset

 che passerà senza problemi in quanto ricevuto direttamente dal server alla
 richiesta precedente.
\end_layout

\begin_layout Enumerate
A causa del fatto che il valore di 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

num_rsp_handles
\end_layout

\end_inset

 del servizio 
\emph on
con 
\emph default

\begin_inset Formula $\text{UUID}=0\text{xBEEF}$
\end_inset

 è minore di quello del servizio con 
\begin_inset Formula $\text{UUID}=0\text{xDEAD}$
\end_inset

, si otterrà l'
\emph on
underflow
\emph default
 sperato.
\begin_inset Newline newline
\end_inset

L'estratto di codice precedente si aspetterà di dover inviare una risposta
 molto grande (fino a 
\begin_inset Formula $64$
\end_inset

KB) e il codice seguente copierà tanti byte quanti ne entrano in un pacchetto
 di risposta a partire dal precedente valore di offset.
\begin_inset Newline newline
\end_inset


\begin_inset listings
lstparams "language={C++},tabsize=4"
inline false
status open

\begin_layout Plain Layout

for (xx = cont_offset; xx < cont_offset + cur_handles; xx++)
\end_layout

\begin_layout Plain Layout

	UINT32_TO_BE_STREAM(p_rsp, rsp_handles[xx]);
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Da questo punto in poi l'attaccante può ripetere la stessa richiesta al
 servizio con 
\begin_inset Formula $\text{UUID}=0\text{xBEEF}$
\end_inset

 apponendo il valore di 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

cont_offset
\end_layout

\end_inset

 ricevuto dal server alla richiesta precedente, continuando così a leggere
 byte nello stack fino a consumare il numero totale di frammenti specificato
 in 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

num_rsp_handles
\end_layout

\end_inset

 (vedi Figura 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:sdp-stack-overflow"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
colorbitbox}[3]{%
\end_layout

\begin_layout Plain Layout

	
\backslash
rlap{
\backslash
bitbox{#2}{
\backslash
color{#1}
\backslash
rule{
\backslash
width}{
\backslash
height}}}%
\end_layout

\begin_layout Plain Layout

	
\backslash
bitbox{#2}{#3}}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{bytefield}{16}
\end_layout

\begin_layout Plain Layout

	
\backslash
bitbox[]{8}{} & 
\backslash
bitbox[lrb]{8}{
\backslash
dots} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

	
\backslash
begin{rightwordgroup}{
\backslash
scriptsize 
\backslash
texttt{SDP
\backslash
_MAX
\backslash
_RECORDS}}
\end_layout

\begin_layout Plain Layout

		
\backslash
begin{leftwordgroup}{
\backslash
scriptsize 
\backslash
texttt{num
\backslash
_rsp
\backslash
_handles} 
\backslash

\backslash
 
\backslash
scriptsize dopo l
\backslash
textquotesingle underflow}
\end_layout

\begin_layout Plain Layout

			
\backslash
bitbox[]{8}{
\backslash
scriptsize 
\backslash
texttt{rsp
\backslash
_handles}} &
\end_layout

\begin_layout Plain Layout

				
\backslash
colorbitbox{green!15}{8}{
\backslash
small 
\backslash
texttt{sdp record}} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

			
\backslash
bitbox[]{8}{} & 
\backslash
colorbitbox{green!15}{8}{
\backslash
small 
\backslash
texttt{sdp record}} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

			
\backslash
bitbox[]{8}{
\backslash
scriptsize 
\backslash
texttt{rsp
\backslash
_handles + 
\backslash

\backslash
 cont
\backslash
_offset}} &
\end_layout

\begin_layout Plain Layout

				
\backslash
colorbitbox{green!15}{8}{
\backslash
small 
\backslash
texttt{sdp record}} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

			
\backslash
bitbox[]{8}{} & 
\backslash
colorbitbox{green!15}{8}{
\backslash
small 
\backslash
texttt{sdp record}} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		
\backslash
bitbox[]{8}{} & 
\backslash
colorbitbox{yellow!15}{8}{
\backslash
small 
\backslash
texttt{0x00000000}} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		
\backslash
bitbox[]{8}{} & 
\backslash
colorbitbox{yellow!15}{8}{
\backslash
small 
\backslash
texttt{0x00000000}}
\end_layout

\begin_layout Plain Layout

	
\backslash
end{rightwordgroup} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

	
\backslash
bitbox[]{8}{} & 
\backslash
colorbitbox{red!15}{8}{
\backslash
dots} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

	
\backslash
bitbox[]{8}{} & 
\backslash
colorbitbox{red!15}{8}{
\backslash
dots} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

	
\backslash
bitbox[]{8}{
\backslash
scriptsize 
\backslash
texttt{rsp
\backslash
_handles + 
\backslash

\backslash
 rem
\backslash
_handles}} &
\end_layout

\begin_layout Plain Layout

		
\backslash
colorbitbox{red!15}{8}{
\backslash
dots}
\end_layout

\begin_layout Plain Layout

	
\backslash
end{leftwordgroup} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

	
\backslash
bitbox[]{8}{} & 
\backslash
bitbox[lrt]{8}{
\backslash
dots}
\end_layout

\begin_layout Plain Layout

 
\backslash
end{bytefield}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\size small
In verde i record SDP che il client può leggere.
 In giallo i record SDP che il client non dovrebbe leggere, ma che non contengon
o informazioni perché azzerati.
 In rosso i dati presenti sullo stack a cui l'utente accede grazie all'
\emph on
underflow
\emph default
 della variabile 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

num_rsp_handles
\end_layout

\end_inset

 e che potrebbero contenere informazioni rilevanti.
\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:sdp-stack-overflow"

\end_inset

Vista dello stack SDP dopo una richiesta malformata
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
I dati ottenuti in questo modo potenzialmente potrebbero contenere chiavi
 di cifratura, puntatori a dati o a codice, o altri dati che possono essere
 utilizzati ad esempio per bypassare meccanismi di mitigazione del sistema
 operativo come l'
\begin_inset Flex CT - acronym
status collapsed

\begin_layout Plain Layout

ASLR
\end_layout

\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Misura di protezione che consiste nel rendere (parzialmente) casuale l'indirizzo
 delle funzioni di libreria e delle più importanti aree di memoria.
 In questo modo un attacco che cerca di eseguire codice malevolo su un computer
 è costretto a cercare gli indirizzi del codice e dei dati che gli servono
 prima di poterli usare.
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Per ultima, ma non meno importante, è anche la possibilità di creare un
 disservizio facendo si che il puntatore ai dati da leggere per costruire
 la risposta SDP punti ad un'area riservata del sistema operativo.
 L'accesso a queste aree di memoria, infatti, portano generalmente al riavvio
 improvviso del dispositivo.
\end_layout

\begin_layout Section
Andorid RCE (CVE-2017-0781)
\begin_inset CommandInset label
LatexCommand label
name "sec:Andorid-RCE-(CVE-2017-0781)"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset citation
LatexCommand nocite
key "blueborne_android_rce_white_paper"

\end_inset


\end_layout

\begin_layout Standard
La vulnerabilità in questione si trova in 
\begin_inset CommandInset href
LatexCommand href
name "/stack/bnep/bnep_main.c"
target "https://android.googlesource.com/platform/system/bt/+/android-7.1.1_r44/stack/bnep/bnep_main.c#475"

\end_inset

, in particolare nella funzione che gestisce i dati in transito su una connessio
ne L2CAP da e verso il server BNEP:
\end_layout

\begin_layout Standard

\size small
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline false
status open

\begin_layout Plain Layout

static void bnep_data_ind (UINT16 l2cap_cid, BT_HDR *p_buf);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Andando ad analizzare la sua implementazione poniamo la nostra attenzione
 sul seguente estratto:
\end_layout

\begin_layout Standard

\size small
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline false
status open

\begin_layout Plain Layout

UINT8 *p = (UINT8 *)(p_buf + 1) + p_buf->offset;
\end_layout

\begin_layout Plain Layout

UINT16 rem_len = p_buf->len;
\end_layout

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

/* Get the type and extension bits */
\end_layout

\begin_layout Plain Layout

type = *p++;
\end_layout

\begin_layout Plain Layout

extension_present = type >> 7;
\end_layout

\begin_layout Plain Layout

type &= 0x7f;
\end_layout

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

switch (type)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

case BNEP_FRAME_CONTROL:
\end_layout

\begin_layout Plain Layout

	ctrl_type = *p;
\end_layout

\begin_layout Plain Layout

	p = bnep_process_control_packet(p_bcb, p, &rem_len, FALSE);
\end_layout

\begin_layout Plain Layout

	if (ctrl_type == BNEP_SETUP_CONNECTION_REQUEST_MSG &&
\end_layout

\begin_layout Plain Layout

		p_bcb->con_state != BNEP_STATE_CONNECTED &&
\end_layout

\begin_layout Plain Layout

		extension_present && p && rem_len)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		p_bcb->p_pending_data = (BT_HDR *)osi_malloc(rem_len);
\end_layout

\begin_layout Plain Layout

		memcpy((UINT8 *)(p_bcb->p_pending_data + 1), p, rem_len);
\end_layout

\begin_layout Plain Layout

		p_bcb->p_pending_data->len = rem_len;
\end_layout

\begin_layout Plain Layout

		p_bcb->p_pending_data->offset = 0;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

...
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Come si può vedere il codice dell'istruzione 
\size small

\begin_inset listings
lstparams "tabsize=4"
inline true
status open

\begin_layout Plain Layout

if
\end_layout

\end_inset

 
\size default
viene eseguito al verificarsi di diverse condizioni relative al formato
 del pacchetto (vedi Figura 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:bnep-vulnerable-function-accepted-packet-format"

\end_inset

) e allo stato della connessione, in particolare:
\end_layout

\begin_layout Itemize
il campo 
\emph on
BNEP Type
\emph default
 dell'header BNEP è posto al valore 
\begin_inset Formula $0\text{x}01$
\end_inset

 (
\size small

\begin_inset listings
lstparams "tabsize=4"
inline true
status open

\begin_layout Plain Layout

BNEP_FRAME_CONTROL
\end_layout

\end_inset

)
\end_layout

\begin_layout Itemize
il campo 
\emph on
BNEP Control Type 
\emph default
è posto al valore 
\begin_inset Formula $0\text{x}01$
\end_inset

 (
\size small

\begin_inset listings
lstparams "tabsize=4"
inline true
status open

\begin_layout Plain Layout

BNEP_SETUP_CONNECTION_REQUEST_MSG
\end_layout

\end_inset


\size default
)
\end_layout

\begin_layout Itemize
il campo 
\emph on
Extension 
\emph default
è uguale a 
\begin_inset Formula $1$
\end_inset

, cioè sono presenti degli 
\emph on
extension header
\end_layout

\begin_layout Itemize
la connessione tra client e server non è ancora stata completata
\end_layout

\begin_layout Standard
\align center
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
colorbitbox}[3]{%
\end_layout

\begin_layout Plain Layout

	
\backslash
rlap{
\backslash
bitbox{#2}{
\backslash
color{#1}
\backslash
rule{
\backslash
width}{
\backslash
height}}}%
\end_layout

\begin_layout Plain Layout

	
\backslash
bitbox{#2}{#3}}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{bytefield}[%
\end_layout

\begin_layout Plain Layout

	boxformatting={
\backslash
centering
\backslash
itshape},
\end_layout

\begin_layout Plain Layout

	bitwidth=1em]{32}
\end_layout

\begin_layout Plain Layout

	
\backslash
bitheader[endianness=little]{0,6,7,8,15,16,31} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		
\backslash
colorbitbox{blue!15}{7}{
\backslash
scriptsize BNEP Type = 
\backslash
(0x01
\backslash
)} &
\end_layout

\begin_layout Plain Layout

		
\backslash
colorbitbox{blue!15}{1}{
\backslash
tiny E 
\backslash

\backslash
 
\backslash
tiny (
\backslash
(1
\backslash
))} &
\end_layout

\begin_layout Plain Layout

		
\backslash
colorbitbox{yellow!15}{8}{
\backslash
scriptsize BNEP Control Type = 
\backslash
(0x01
\backslash
)} &
\end_layout

\begin_layout Plain Layout

		
\backslash
colorbitbox{cyan!15}{8}{
\backslash
scriptsize UUID Size} &
\end_layout

\begin_layout Plain Layout

		
\backslash
colorbitbox{cyan!15}{8}{
\backslash
scriptsize Destination Service UUID 
\backslash

\backslash
 
\backslash
tiny (Byte 
\backslash
(0
\backslash
))} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		
\backslash
colorbitbox{cyan!15}{24}{
\backslash
scriptsize Destination Service UUID 
\backslash

\backslash
 
\backslash
tiny (Byte 
\backslash
(1-N
\backslash
))} &
\end_layout

\begin_layout Plain Layout

		
\backslash
colorbitbox{cyan!15}{8}{
\backslash
scriptsize Source Service UUID 
\backslash

\backslash
 
\backslash
tiny (Byte 
\backslash
(0
\backslash
))} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		
\backslash
colorbitbox{cyan!15}{24}{
\backslash
scriptsize Source Service UUID 
\backslash

\backslash
 
\backslash
tiny (Byte 
\backslash
(1-N
\backslash
))} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		
\backslash
colorbitbox{blue!15}{7}{
\backslash
scriptsize Extension Type = 
\backslash
(0x00
\backslash
)} &
\end_layout

\begin_layout Plain Layout

		
\backslash
colorbitbox{blue!15}{1}{
\backslash
tiny E 
\backslash

\backslash
 
\backslash
tiny (
\backslash
(1
\backslash
))} &
\end_layout

\begin_layout Plain Layout

		
\backslash
colorbitbox{blue!15}{8}{
\backslash
scriptsize Extension Length} &
\end_layout

\begin_layout Plain Layout

		
\backslash
colorbitbox{yellow!15}{8}{
\backslash
scriptsize BNEP Control Type} &
\end_layout

\begin_layout Plain Layout

		
\backslash
colorbitbox{cyan!15}{8}{
\backslash
tiny Pacchetto di controllo basato sul Control Type} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		
\backslash
wordbox[]{1}{$
\backslash
vdots$} 
\backslash

\backslash
[1ex]
\end_layout

\begin_layout Plain Layout

		
\backslash
colorbitbox{blue!15}{7}{
\backslash
scriptsize Extension Type = 
\backslash
(0x00
\backslash
)} &
\end_layout

\begin_layout Plain Layout

		
\backslash
colorbitbox{blue!15}{1}{
\backslash
tiny E 
\backslash

\backslash
 
\backslash
tiny (
\backslash
(1
\backslash
))} &
\end_layout

\begin_layout Plain Layout

		
\backslash
colorbitbox{blue!15}{8}{
\backslash
scriptsize Extension Length} &
\end_layout

\begin_layout Plain Layout

		
\backslash
colorbitbox{yellow!15}{8}{
\backslash
scriptsize BNEP Control Type} &
\end_layout

\begin_layout Plain Layout

		
\backslash
colorbitbox{cyan!15}{8}{
\backslash
tiny Pacchetto di controllo basato sul Control Type} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		
\backslash
colorbitbox{blue!15}{7}{
\backslash
scriptsize Extension Type = 
\backslash
(0x00
\backslash
)} &
\end_layout

\begin_layout Plain Layout

		
\backslash
colorbitbox{blue!15}{1}{
\backslash
tiny E 
\backslash

\backslash
 
\backslash
tiny (
\backslash
(0
\backslash
))} &
\end_layout

\begin_layout Plain Layout

		
\backslash
colorbitbox{blue!15}{8}{
\backslash
scriptsize Extension Length} &
\end_layout

\begin_layout Plain Layout

		
\backslash
colorbitbox{yellow!15}{8}{
\backslash
scriptsize BNEP Control Type} &
\end_layout

\begin_layout Plain Layout

		
\backslash
colorbitbox{cyan!15}{8}{
\backslash
tiny Pacchetto di controllo basato sul Control Type} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
end{bytefield}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:bnep-vulnerable-function-accepted-packet-format"

\end_inset

Formato del pacchetto BNEP che permette di raggiungere il codice vulnerabile
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Quando tutte queste condizioni si verificano simultaneamente il server BNEP
 avvia in modo asincrono la richiesta di connessione e mette in coda i messaggi
 di controllo successivi nel buffer 
\size small

\begin_inset listings
lstparams "tabsize=4"
inline true
status open

\begin_layout Plain Layout

p_pending_data
\end_layout

\end_inset


\size default
.
 Questo avviene in quanto quando i messaggi di controllo presenti negli
 
\emph on
extension header
\emph default
 seguono l'header BNEP per la richiesta di collegamento è possibile che
 questi richiedano una connessione già instaurata, quindi non possono essere
 processati subito.
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
Il codice che si occupa di mettere in coda i messaggi di controllo è:
\end_layout

\begin_layout Standard

\size small
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline false
status open

\begin_layout Plain Layout

p_bcb->p_pending_data = (BT_HDR *)osi_malloc(rem_len);
\end_layout

\begin_layout Plain Layout

memcpy((UINT8 *)(p_bcb->p_pending_data + 1), p, rem_len);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Come si può notare il buffer 
\size small

\begin_inset listings
lstparams "tabsize=4"
inline true
status open

\begin_layout Plain Layout

p_pending_data
\end_layout

\end_inset


\size default
 è allocato sull'heap con dimensione 
\size small

\begin_inset listings
lstparams "tabsize=4"
inline true
status open

\begin_layout Plain Layout

rem_len
\end_layout

\end_inset

 ed è
\size default
 di tipo 
\size small

\begin_inset listings
lstparams "tabsize=4"
inline true
status open

\begin_layout Plain Layout

BT_HDR
\end_layout

\end_inset


\size default
, cioè una struttura definita come segue:
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "code:BT_HDR"

\end_inset


\end_layout

\begin_layout Standard

\size small
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline false
status open

\begin_layout Plain Layout

typedef struct {
\end_layout

\begin_layout Plain Layout

	uint16_t event;
\end_layout

\begin_layout Plain Layout

	uint16_t len;
\end_layout

\begin_layout Plain Layout

	uint16_t offset;
\end_layout

\begin_layout Plain Layout

	uint16_t layer_specific;
\end_layout

\begin_layout Plain Layout

	uint8_t data[];
\end_layout

\begin_layout Plain Layout

} BT_HDR;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Successivamente i 
\size small

\begin_inset listings
lstparams "tabsize=4"
inline true
status open

\begin_layout Plain Layout

rem_len
\end_layout

\end_inset


\size default
 byte dei messaggi di controllo negli 
\emph on
extension header
\emph default
 vengono copiati da 
\size small

\begin_inset listings
lstparams "tabsize=4"
inline true
status open

\begin_layout Plain Layout

p
\end_layout

\end_inset


\size default
 in 
\size small

\begin_inset listings
lstparams "tabsize=4"
inline true
status open

\begin_layout Plain Layout

p_pending_data + 1
\end_layout

\end_inset


\size default
, cioè in 
\size small

\begin_inset listings
lstparams "tabsize=4"
inline true
status open

\begin_layout Plain Layout

p_pending_data->data
\end_layout

\end_inset


\size default
.
\end_layout

\begin_layout Standard
Il problema nasce dal fatto che la copia dei dati si comporta come se nell'heap
 avessimo allocato la memoria necessaria a contenere sia la struttura 
\size small

\begin_inset listings
lstparams "tabsize=4"
inline true
status open

\begin_layout Plain Layout

BT_HDR
\end_layout

\end_inset


\size default
 che il buffer 
\size small

\begin_inset listings
lstparams "tabsize=4"
inline true
status open

\begin_layout Plain Layout

data[]
\end_layout

\end_inset


\size default
 di dimensione 
\size small

\begin_inset listings
lstparams "tabsize=4"
inline true
status open

\begin_layout Plain Layout

rem_len
\end_layout

\end_inset


\size default
 (vedi Figura 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:bnep-heap-without-overflow"

\end_inset

), mentre la memoria realmente allocata è solo quella necessaria a contenere
 il buffer.
 Quando viene eseguita la copia, quindi, gli ultimi 
\begin_inset Formula $8$
\end_inset

 byte vengono scritti al di fuori dello spazio di memoria allocato, come
 mostrato in Figura 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:bnep-heap-with-overflow"

\end_inset

.
\end_layout

\begin_layout Standard
\align center
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{bytefield}{10}
\end_layout

\begin_layout Plain Layout

	
\backslash
wordbox[lrb]{1}{
\backslash
dots} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

	
\backslash
begin{leftwordgroup}{
\backslash
small 
\backslash
texttt{p
\backslash
_pending
\backslash
_data}}
\end_layout

\begin_layout Plain Layout

		
\backslash
wordbox[lrt]{1}{
\backslash
small 
\backslash
texttt{event}} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		
\backslash
wordbox[lrb]{1}{} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		
\backslash
wordbox[lrt]{1}{
\backslash
small 
\backslash
texttt{len
\backslash
(=
\backslash
)rem
\backslash
_len}} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		
\backslash
wordbox[lrb]{1}{} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		
\backslash
wordbox[lrt]{1}{
\backslash
small 
\backslash
texttt{offset
\backslash
(=0
\backslash
)}} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		
\backslash
wordbox[lrb]{1}{} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		
\backslash
wordbox[lrt]{1}{
\backslash
small 
\backslash
texttt{layer
\backslash
_specific}} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		
\backslash
wordbox[lrb]{1}{} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		
\backslash
begin{rightwordgroup}{
\backslash
texttt{rem
\backslash
_len} byte}
\end_layout

\begin_layout Plain Layout

			
\backslash
wordbox{1}{
\backslash
small 
\backslash
texttt{data[0]}} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

			
\backslash
wordbox{1}{
\backslash
small 
\backslash
texttt{data[1]}} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

			
\backslash
wordbox{1}{
\backslash
vdots} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

			
\backslash
wordbox{1}{
\backslash
small 
\backslash
texttt{data[rem
\backslash
_len-2]}} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

			
\backslash
wordbox{1}{
\backslash
small 
\backslash
texttt{data[rem
\backslash
_len-1]}}
\end_layout

\begin_layout Plain Layout

		
\backslash
end{rightwordgroup}
\end_layout

\begin_layout Plain Layout

	
\backslash
end{leftwordgroup} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	
\backslash
wordbox[lrt]{1}{
\backslash
dots} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

 
\backslash
end{bytefield}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:bnep-heap-without-overflow"

\end_inset

Vista della struttura 
\family typewriter
p_pending_data
\family default
 nell'heap come dovrebbe essere
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
colorbitbox}[3]{%
\end_layout

\begin_layout Plain Layout

	
\backslash
rlap{
\backslash
bitbox{#2}{
\backslash
color{#1}
\backslash
rule{
\backslash
width}{
\backslash
height}}}%
\end_layout

\begin_layout Plain Layout

	
\backslash
bitbox{#2}{#3}}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{bytefield}{10}
\end_layout

\begin_layout Plain Layout

	
\backslash
wordbox[lrb]{1}{
\backslash
dots} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

	
\backslash
begin{leftwordgroup}{
\backslash
small 
\backslash
texttt{p
\backslash
_pending
\backslash
_data}}
\end_layout

\begin_layout Plain Layout

	
\backslash
begin{rightwordgroup}{
\backslash
texttt{rem
\backslash
_len} byte}
\end_layout

\begin_layout Plain Layout

		
\backslash
wordbox[lrt]{1}{
\backslash
small 
\backslash
texttt{event}} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		
\backslash
wordbox[lrb]{1}{} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		
\backslash
wordbox[lrt]{1}{
\backslash
small 
\backslash
texttt{len
\backslash
(=
\backslash
)rem
\backslash
_len}} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		
\backslash
wordbox[lrb]{1}{} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		
\backslash
wordbox[lrt]{1}{
\backslash
small 
\backslash
texttt{offset
\backslash
(=0
\backslash
)}} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		
\backslash
wordbox[lrb]{1}{} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		
\backslash
wordbox[lrt]{1}{
\backslash
small 
\backslash
texttt{layer
\backslash
_specific}} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		
\backslash
wordbox[lrb]{1}{} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		
\backslash
wordbox{1}{
\backslash
small 
\backslash
texttt{data[0]}} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		
\backslash
wordbox{1}{
\backslash
small 
\backslash
texttt{data[1]}} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		
\backslash
wordbox{1}{
\backslash
vdots}
\end_layout

\begin_layout Plain Layout

	
\backslash
end{rightwordgroup}
\end_layout

\begin_layout Plain Layout

	
\backslash
end{leftwordgroup} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	
\backslash
begin{rightwordgroup}{byte in overflow}
\end_layout

\begin_layout Plain Layout

		
\backslash
colorbitbox{red!15}{10}{
\backslash
small 
\backslash
texttt{data[rem
\backslash
_len-8]}} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		
\backslash
colorbitbox{red!15}{10}{
\backslash
small 
\backslash
texttt{data[rem
\backslash
_len-7]}} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		
\backslash
colorbitbox{red!15}{10}{
\backslash
small 
\backslash
texttt{data[rem
\backslash
_len-6]}} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		
\backslash
colorbitbox{red!15}{10}{
\backslash
small 
\backslash
texttt{data[rem
\backslash
_len-5]}} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		
\backslash
colorbitbox{red!15}{10}{
\backslash
small 
\backslash
texttt{data[rem
\backslash
_len-4]}} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		
\backslash
colorbitbox{red!15}{10}{
\backslash
small 
\backslash
texttt{data[rem
\backslash
_len-3]}} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		
\backslash
colorbitbox{red!15}{10}{
\backslash
small 
\backslash
texttt{data[rem
\backslash
_len-2]}} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		
\backslash
colorbitbox{red!15}{10}{
\backslash
small 
\backslash
texttt{data[rem
\backslash
_len-1]}}
\end_layout

\begin_layout Plain Layout

	
\backslash
end{rightwordgroup} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

	
\backslash
wordbox[lrt]{1}{
\backslash
dots} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

 
\backslash
end{bytefield}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:bnep-heap-with-overflow"

\end_inset

Vista della struttura 
\family typewriter
p_pending_data
\family default
 nell'heap come è realmente
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
È importante notare che sia il valore di 
\size small

\begin_inset listings
lstparams "tabsize=4"
inline true
status open

\begin_layout Plain Layout

rem_len
\end_layout

\end_inset


\size default
 che i dati puntati da 
\size small

\begin_inset listings
lstparams "tabsize=4"
inline true
status open

\begin_layout Plain Layout

p
\end_layout

\end_inset


\size default
 sono sotto il controllo dell'attaccante, quindi la domanda da porci ora
 è: cosa succede quando andiamo in 
\emph on
overflow
\emph default
 di 
\begin_inset Formula $8$
\end_inset

 byte?
\end_layout

\begin_layout Standard
Innanzitutto costruiamo un pacchetto che sia in grado di eseguire il frammento
 di codice in esame come mostrato in Figura 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:bnep-vulnerable-function-sample-packet-format"

\end_inset

.
\end_layout

\begin_layout Standard
\align center
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
colorbitbox}[3]{%
\end_layout

\begin_layout Plain Layout

	
\backslash
rlap{
\backslash
bitbox{#2}{
\backslash
color{#1}
\backslash
rule{
\backslash
width}{
\backslash
height}}}%
\end_layout

\begin_layout Plain Layout

	
\backslash
bitbox{#2}{#3}}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{bytefield}[%
\end_layout

\begin_layout Plain Layout

	boxformatting={
\backslash
centering
\backslash
itshape},
\end_layout

\begin_layout Plain Layout

	bitwidth=1em]{32}
\end_layout

\begin_layout Plain Layout

	
\backslash
bitheader[endianness=little]{0,6,7,8,15,16,31} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		
\backslash
colorbitbox{blue!15}{7}{
\backslash
scriptsize BNEP Type = 
\backslash
texttt{0x01}} &
\end_layout

\begin_layout Plain Layout

		
\backslash
colorbitbox{blue!15}{1}{
\backslash
tiny E 
\backslash

\backslash
 
\backslash
tiny (
\backslash
texttt{1})} &
\end_layout

\begin_layout Plain Layout

		
\backslash
colorbitbox{yellow!15}{8}{
\backslash
scriptsize BNEP Control Type = 
\backslash
texttt{0x01}} &
\end_layout

\begin_layout Plain Layout

		
\backslash
colorbitbox{cyan!15}{8}{
\backslash
scriptsize UUID Size = 
\backslash
texttt{0x01}} &
\end_layout

\begin_layout Plain Layout

		
\backslash
colorbitbox{cyan!15}{8}{
\backslash
scriptsize Destination Service UUID = 
\backslash
texttt{0xAA}} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		
\backslash
colorbitbox{cyan!15}{8}{
\backslash
scriptsize Source Service UUID = 
\backslash
texttt{0xBB}} &
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		
\backslash
colorbitbox{red!15}{8}{
\backslash
texttt{0xCC}} &
\end_layout

\begin_layout Plain Layout

		
\backslash
colorbitbox{red!15}{8}{
\backslash
texttt{0xCC}} &
\end_layout

\begin_layout Plain Layout

		
\backslash
colorbitbox{red!15}{8}{
\backslash
texttt{0xCC}} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		
\backslash
colorbitbox{red!15}{8}{
\backslash
texttt{0xCC}} &
\end_layout

\begin_layout Plain Layout

		
\backslash
colorbitbox{red!15}{8}{
\backslash
texttt{0x41}} &
\end_layout

\begin_layout Plain Layout

		
\backslash
colorbitbox{red!15}{8}{
\backslash
texttt{0x41}} &
\end_layout

\begin_layout Plain Layout

		
\backslash
colorbitbox{red!15}{8}{
\backslash
texttt{0x41}} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		
\backslash
colorbitbox{red!15}{8}{
\backslash
texttt{0x41}} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
end{bytefield}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:bnep-vulnerable-function-sample-packet-format"

\end_inset

Formato di un pacchetto BNEP di esempio in grado di eseguire heap overflow
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Dopo aver inviato 
\begin_inset Formula $500\text{-}1000$
\end_inset

 di questi pacchetti (impiegando poco più di 
\begin_inset Formula $1$
\end_inset

 secondo) il demone bluetooth del dispositivo vittima si interrompe.
 Il 
\emph on
crash
\emph default
 è visibile sia sul dispositivo stesso (vedi Fig.
 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:nexus-5x-bluetooth-crash-screenshot"

\end_inset

) che andando ad analizzare i 
\emph on
log
\emph default
 dove vediamo chiaramente che il demone ha cercato di accedere all'indirizzo
 indicato nel nostro pacchetto (
\begin_inset Formula $0\text{x}41414141$
\end_inset

).
\end_layout

\begin_layout Standard
\align center
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename /home/mrnfrancesco/git/master-thesis/gfx/nexus_5x_bluetooth_crash_screenshot.png
	display false
	width 40col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:nexus-5x-bluetooth-crash-screenshot"

\end_inset

Screenshot che mostra il crash del demone Bluetooth dopo l'heap overflow
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "tabsize=4"
inline false
status open

\begin_layout Plain Layout

pid: 6774, tid: 6812, name: bluetooth wake  >>> com.android.bluetooth <<<
\end_layout

\begin_layout Plain Layout

signal 11 (SIGSEGV), code 1 (SEGV_MAPERR), fault addr 0x41414141
\end_layout

\begin_layout Plain Layout

	r0 41414141  r1 00000000  r2 5b7ad2ec  r3 00000008
\end_layout

\begin_layout Plain Layout

	r4 41414141  r5 00000001  r6 e94145b8  r7 d61008d8
\end_layout

\begin_layout Plain Layout

	r8 00000000  r9 d61004b0  sl e693ef20  fp e94145c4
\end_layout

\begin_layout Plain Layout

	ip d61008d8  sp d61004a0  lr f08bb421  pc ef1df8ec  cpsr 000f0030
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

backtrace:
\end_layout

\begin_layout Plain Layout

	#00 pc 000d38ec  /system/lib/hw/bluetooth.default.so
\end_layout

\begin_layout Plain Layout

	#01 pc 000e79a5  /system/lib/hw/bluetooth.default.so
\end_layout

\begin_layout Plain Layout

	#02 pc 000e876b  /system/lib/hw/bluetooth.default.so
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Andando ad analizzare il codice assembly della funzione che ha presentato
 il 
\emph on
crash
\emph default
 indicato nel 
\emph on
backtrace
\emph default
 otteniamo il seguente estratto:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "tabsize=4"
inline false
status open

\begin_layout Plain Layout

0x000d38ea		mov r4, r0			; r4 = r0
\end_layout

\begin_layout Plain Layout

0x000d38ec		ldrh r1, [r4]		; r1 = (uint16)(*r4)
\end_layout

\begin_layout Plain Layout

0x000d38ee		bic r0, r1, 0xff	; r0 = r1 & 0xFF
\end_layout

\begin_layout Plain Layout

...									; ...
\end_layout

\begin_layout Plain Layout

0x000d38f2		cmp.w r0, 0x1600	; if (r0 >= 0x1600)
\end_layout

\begin_layout Plain Layout

0x000d38f6		bge 0xd3914			; 	fn_d3914(r4)
\end_layout

\begin_layout Plain Layout

0x000d38f8		cmp.w r0, 0x1000	; else if (r0 == 0x1000)
\end_layout

\begin_layout Plain Layout

0x000d38fc		beq 0xd392e			; 	fn_d392e(r4)
\end_layout

\begin_layout Plain Layout

0x000d38fe		cmp.w r0, 0x1100	; else if (r0 == 0x1100)
\end_layout

\begin_layout Plain Layout

0x000d3902		beq 0xd3958			; 	fn_d3958(r4)
\end_layout

\begin_layout Plain Layout

0x000d3904		cmp.w r0, 0x1200	; else if (r0 != 0x1200)
\end_layout

\begin_layout Plain Layout

0x000d3908		bne 0xd3978			; 	fn_d3978(r4)
\end_layout

\begin_layout Plain Layout

...									; ...
\end_layout

\begin_layout Plain Layout

0x000d3916		cmp.w r0, 0x1900	; else if (r0 == 0x1900)
\end_layout

\begin_layout Plain Layout

0x000d391a		beq 0xd396e			; 	fn_d396e(r4)
\end_layout

\begin_layout Plain Layout

0x000d391c		cmp.w r0, 0x1700	; else if (r0 == 0x1700) {
\end_layout

\begin_layout Plain Layout

...									; ...
\end_layout

\begin_layout Plain Layout

0x000d3922		ldr r1, [r4, 8]		; 	r1 = *(r4 + 8)
\end_layout

\begin_layout Plain Layout

0x000d3924		mov r0, r4			; 	r0 = r4
\end_layout

\begin_layout Plain Layout

0x000d3926		blx r1				; 	fn_r1(r0)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Sapendo che 
\size small

\begin_inset listings
lstparams "tabsize=4"
inline true
status open

\begin_layout Plain Layout

r4
\end_layout

\end_inset


\size default
 è una copia del parametro 
\size small

\begin_inset listings
lstparams "tabsize=4"
inline true
status open

\begin_layout Plain Layout

r0
\end_layout

\end_inset


\size default
 passato alla funzione, e sapendo che il 
\emph on
crash
\emph default
 avviene durante l'operazione di dereferenziazione di 
\size small

\begin_inset listings
lstparams "tabsize=4"
inline true
status open

\begin_layout Plain Layout

r4
\end_layout

\end_inset


\size default
, sappiamo che questo è un puntatore.
\end_layout

\begin_layout Standard
Analizzando anche la restante parte del codice possiamo capire che si tratta
 di un puntatore a una struttura che si presenta all'incirca nel modo seguente:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=C,tabsize=4"
inline false
status open

\begin_layout Plain Layout

typedef struct {
\end_layout

\begin_layout Plain Layout

	uint16_t <parametro>;
\end_layout

\begin_layout Plain Layout

	// 6 byte di parametri
\end_layout

\begin_layout Plain Layout

	(void)(*)(<struttura> *) <puntatore a funzione>;
\end_layout

\begin_layout Plain Layout

	// eventuali altri parametri
\end_layout

\begin_layout Plain Layout

} <struttura>;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Il primo parametro della struttura viene utilizzato nella catena di 
\size small

\begin_inset listings
lstparams "tabsize=4"
inline true
status open

\begin_layout Plain Layout

if/else
\end_layout

\end_inset


\size default
, ma quello che è più interessante è il caso 
\size small

\begin_inset listings
lstparams "tabsize=4"
inline true
status open

\begin_layout Plain Layout

r0 == 0x1700
\end_layout

\end_inset


\size default
 in cui viene invocata una funzione il cui puntatore è all'offset 
\begin_inset Formula $8$
\end_inset

 all'interno della struttura e il parametro della funzione è la struttura
 stessa, condizione ideale per permettere esecuzione di codice arbitrario.
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
Attraverso ulteriori indagini siamo in grado di identificare nel codice
 sorgente la funzione corrispondente all'estratto appena analizzato.
 La funzione in questione si trova in 
\begin_inset CommandInset href
LatexCommand href
name "/stack/btu/btu_task.c"
target "https://android.googlesource.com/platform/system/bt/+/android-7.1.1_r44/stack/btu/btu_task.c#117"

\end_inset

 ed è
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline false
status open

\begin_layout Plain Layout

static void btu_hci_msg_process(BT_HDR *p_msg);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
la cui implementazione è la seguente
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline false
status open

\begin_layout Plain Layout

/* Determine the input message type.
 */
\end_layout

\begin_layout Plain Layout

switch (p_msg->event & BT_EVT_MASK)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	case BTU_POST_TO_TASK_NO_GOOD_HORRIBLE_HACK:
\end_layout

\begin_layout Plain Layout

		((post_to_task_hack_t *)(&p_msg->data[0]))->callback(p_msg);
\end_layout

\begin_layout Plain Layout

		...
\end_layout

\begin_layout Plain Layout

		break;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	case BT_EVT_TO_BTU_HCI_ACL:
\end_layout

\begin_layout Plain Layout

		l2c_rcv_acl_data (p_msg);
\end_layout

\begin_layout Plain Layout

		break;
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	case BT_EVT_TO_BTU_L2C_SEG_XMIT:
\end_layout

\begin_layout Plain Layout

		l2c_link_segments_xmitted (p_msg);
\end_layout

\begin_layout Plain Layout

		break;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Il 
\emph on
crash
\emph default
 del demone Bluetooth avviene durante l'esecuzione della dereferenziazione
 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

p_msg->event
\end_layout

\end_inset

 (equivalente a 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

r1 = (*r4)
\end_layout

\end_inset

) in quanto, lo ripetiamo, dopo l'heap overflow il puntatore alla struttura
 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

p_msg
\end_layout

\end_inset

 è uguale all'indirizzo 
\begin_inset Formula $0\text{x}41414141$
\end_inset

.
\end_layout

\begin_layout Standard
L'evento per cui 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

r0 == 0x1700
\end_layout

\end_inset

 si verifica quando 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline false
status open

\begin_layout Plain Layout

(p_msg->event & BT_EVT_MASK) == BTU_POST_TO_TASK_NO_GOOD_HORRIBLE_HACK
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Se questa condizione è vera viene eseguito
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline false
status open

\begin_layout Plain Layout

((post_to_task_hack_t *)(&p_msg->data[0]))->callback(p_msg);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
dove la struttura 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

post_to_task_hack_t
\end_layout

\end_inset

 è definita in 
\begin_inset CommandInset href
LatexCommand href
name "/stack/include/btu.h"
target "https://android.googlesource.com/platform/system/bt/+/android-7.1.1_r44/stack/include/btu.h#34"

\end_inset

 come segue
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline false
status open

\begin_layout Plain Layout

typedef struct {
\end_layout

\begin_layout Plain Layout

	void (*callback)(BT_HDR *);
\end_layout

\begin_layout Plain Layout

} post_to_task_hack_t;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A questo punto sappiamo con certezza che sia il parametro della funzione
 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

btu_hci_msg_process
\end_layout

\end_inset

 che quello della callback nella struttura 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

post_to_task_hack_t
\end_layout

\end_inset

 sono di tipo 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

BT_HDR
\end_layout

\end_inset

 (già incontrato in precedenza 
\begin_inset CommandInset ref
LatexCommand vpageref
reference "code:BT_HDR"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
endgroup
\end_layout

\end_inset


\end_layout

\end_body
\end_document
