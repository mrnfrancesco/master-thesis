#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass classicthesis
\use_default_options true
\maintain_unincluded_children false
\language italian
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine natbib
\cite_engine_type numerical
\biblio_style plainnat
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 2
\tocdepth 2
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begingroup
\end_layout

\begin_layout Plain Layout


\backslash
let
\backslash
clearpage
\backslash
relax
\end_layout

\begin_layout Plain Layout


\backslash
let
\backslash
cleardoublepage
\backslash
relax
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align right
\begin_inset Graphics
	filename /home/mrnfrancesco/git/master-thesis/gfx/blueborne-logo.png
	display false
	width 2.5cm

\end_inset


\end_layout

\begin_layout Chapter
BlueBorne
\begin_inset CommandInset label
LatexCommand label
name "ch:blueborne"

\end_inset


\end_layout

\begin_layout Section
Android Information Leak (CVE-2017-0785)
\end_layout

\begin_layout Standard
\begin_inset CommandInset citation
LatexCommand nocite
key "blueborne_white_paper"

\end_inset


\end_layout

\begin_layout Standard
La struttura del 
\emph on
Continuation State
\emph default
 utilizzata nell'implementazione Android dello stack Bluetooth è la seguente:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language={C++},showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout

typedef struct { 
\end_layout

\begin_layout Plain Layout

	uint16_t cont_offset;
\end_layout

\begin_layout Plain Layout

} sdp_cont_state_t;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In questo caso la struttura presenta solamente un offset di 
\begin_inset Formula $16$
\end_inset

 bit che indica quale frammento inviare alla prossima richiesta.
\end_layout

\begin_layout Standard
La funzione che gestisce tutte le richieste SDP si trova in 
\begin_inset listings
lstparams "tabsize=4"
inline true
status open

\begin_layout Plain Layout

/stack/sdp/sdp_server.cc
\end_layout

\end_inset

 ed ha la seguente firma:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline false
status open

\begin_layout Plain Layout

void sdp_server_handle_client_req (tCONN_CB * p_ccb, BT_HDR * p_msg);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Come indicato nella documentazione, la funzione riceve tutti i dati derivanti
 dal livello L2CAP e li passa alla funzione appropriata per la gestione.
 Un estratto del codice è il seguente:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline false
status open

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

/* The first byte in the message is the pdu type */
\end_layout

\begin_layout Plain Layout

pdu_id = *p_req++;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Extract the transaction number and parameter length */
\end_layout

\begin_layout Plain Layout

BE_STREAM_TO_UINT16(trans_num, p_req);
\end_layout

\begin_layout Plain Layout

BE_STREAM_TO_UINT16(param_len, p_req);
\end_layout

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

switch (pdu_id) {
\end_layout

\begin_layout Plain Layout

	case SDP_PDU_SERVICE_SEARCH_REQ:
\end_layout

\begin_layout Plain Layout

		process_service_search(p_ccb, trans_num, param_len, p_req, p_req_end);
\end_layout

\begin_layout Plain Layout

		break;
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Proseguendo nell'albero delle chiamate andiamo ad analizzare la funzione
 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

process_service_search
\end_layout

\end_inset

 che si occupa di gestire le 
\emph on
service search request
\emph default
 spiegate nella sezione 
\begin_inset CommandInset ref
LatexCommand nameref
reference "subsec:sdp-service-search"

\end_inset

 
\begin_inset CommandInset ref
LatexCommand vpageref
reference "subsec:sdp-service-search"

\end_inset

.
\end_layout

\begin_layout Standard
La funzione si trova anch'essa in 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

/stack/sdp/sdp_server.cc
\end_layout

\end_inset

 con la seguente firma:
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline false
status open

\begin_layout Plain Layout

static void process_service_search(
\end_layout

\begin_layout Plain Layout

	tCONN_CB* p_ccb,
\end_layout

\begin_layout Plain Layout

	uint16_t trans_num,
\end_layout

\begin_layout Plain Layout

	uint16_t param_len,
\end_layout

\begin_layout Plain Layout

	uint8_t* p_req,
\end_layout

\begin_layout Plain Layout

	UNUSED_ATTR uint8_t* p_req_end
\end_layout

\begin_layout Plain Layout

);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Andando ad analizzare la sua implementazione poniamo la nostra attenzione
 sul seguente estratto:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language={C++},showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout

uint16_t cur_handles, rem_handles, cont_offset, num_rsp_handles;
\end_layout

\begin_layout Plain Layout

uint32_t rsp_handles[SDP_MAX_RECORDS] = {0};
\end_layout

\begin_layout Plain Layout

tSDP_RECORD* p_rec = NULL;
\end_layout

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

/* Check if this is a continuation request */
\end_layout

\begin_layout Plain Layout

if (*p_req) {
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

	if (cont_offset != p_ccb->cont_offset) {
\end_layout

\begin_layout Plain Layout

		sdpu_build_n_send_error(
\end_layout

\begin_layout Plain Layout

			p_ccb,
\end_layout

\begin_layout Plain Layout

			trans_num,
\end_layout

\begin_layout Plain Layout

			SDP_INVALID_CONT_STATE,
\end_layout

\begin_layout Plain Layout

			SDP_TEXT_BAD_CONT_INX
\end_layout

\begin_layout Plain Layout

		);
\end_layout

\begin_layout Plain Layout

		return;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	/* extract the remaining handles */
\end_layout

\begin_layout Plain Layout

	rem_handles = num_rsp_handles - cont_offset;
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

/* Calculate how many handles will fit in one PDU */
\end_layout

\begin_layout Plain Layout

cur_handles =
\end_layout

\begin_layout Plain Layout

	(uint16_t)((pccb->rem_mtu_size - SDP_MAX_SERVICE_RSPHDR_LEN) / 4);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if (rem_handles <= cur_handles)
\end_layout

\begin_layout Plain Layout

	cur_handles = rem_handles;
\end_layout

\begin_layout Plain Layout

else { /* Continuation is set */
\end_layout

\begin_layout Plain Layout

	p_ccb->cont_offset += cur_handles;
\end_layout

\begin_layout Plain Layout

	is_cont = true;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

for (xx = cont_offset; xx < cont_offset + cur_handles; xx++)
\end_layout

\begin_layout Plain Layout

	UINT32_TO_BE_STREAM(p_rsp, rsp_handles[xx]);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Come si può notare il codice mantiene una copia del valore di 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

cont_offset
\end_layout

\end_inset

 (equivalente al 
\emph on
Continuation State Value
\emph default
) nell'oggetto 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

p_ccb
\end_layout

\end_inset

 che mantiene le informazioni di connessione, e controlla che il valore
 ricevuto sia uguale a quello atteso; se i due valori differiscono la funzione
 termina segnalando l'errore.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline false
status open

\begin_layout Plain Layout

if (cont_offset != p_ccb->cont_offset) {
\end_layout

\begin_layout Plain Layout

	sdpu_build_n_send_error(...);
\end_layout

\begin_layout Plain Layout

	return;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In questo scenario non è possibile abusare di un valore di 
\emph on
continuation state
\emph default
 malformato che permetta di leggere zone di memoria arbitrarie.
 Tuttavia, come già visto in Figura 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:sdp-continuation-state-workflow"

\end_inset

, per il recupero dell'intera risposta il meccanismo di frammentazione del
 livello SDP si aspetta che la richiesta fatta del client sia sempre la
 stessa, mentre a variare è il valore del 
\emph on
continuation state
\emph default
.
 Possiamo notare come l'estratto di codice della funzione 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

process_service_search
\end_layout

\end_inset

 non abbia alcun controllo sulla consistenza dei parametri di due o più
 richieste successive; possiamo quindi sfruttare questo per portare il codice
 in uno stato inconsistente.
\end_layout

\begin_layout Standard
Il numero di frammenti rimanenti da inviare al client non viene salvato
 nell'oggetto 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

p_ccb
\end_layout

\end_inset

 per essere validato alla ricezione di una nuova richiesta, ma è calcolato
 ad ogni invocazione della funzione eseguendo:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline false
status open

\begin_layout Plain Layout

rem_handles = num_rsp_handles - cont_offset;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
dove 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

num_rsp_handles
\end_layout

\end_inset

 rappresenta il numero totale di frammenti della risposta all'attuale richiesta
 SDP, mentre 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

cont_offset
\end_layout

\end_inset

, lo ricordiamo, è l'offset del frammento corrente da leggere.
\end_layout

\begin_layout Standard
La mancanza di questo controllo nasce dall'assunzione (errata) che due richieste
 successive facciano riferimento alla stessa risposta.
\end_layout

\begin_layout Standard
Se quindi potessimo sfruttare questa situazione per portare il valore di
 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

rem_handles
\end_layout

\end_inset

 ad essere maggiore del reale numero dei frammenti rimanenti tramite 
\emph on
underflow
\emph default

\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Si ha quando il risultato di un calcolo è un numero minore del valore minore
 rappresentabile.
 La conseguenza è quella di ottenere valori generalmente molto alti, vicini
 al massimo valore rappresentabile.
\end_layout

\end_inset

, durante il 
\emph on
loop
\emph default
 di lettura dei frammenti si andrebbero a leggere sequenze di byte nello
 stack oltre quelle consentite, che verrebbero restituite nella risposta
 SDP ottenendo così una vulnerabilità di tipo 
\emph on
Information Exposure
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Divulgazione intenzionale o non intenzionale di informazioni a un attore
 - che non è esplicitamente autorizzato ad avere accesso a quell'informazione
\end_layout

\end_inset


\emph default
 (
\begin_inset CommandInset href
LatexCommand href
name "CWE-200"
target "http://cwe.mitre.org/data/definitions/200.html"

\end_inset

).
\end_layout

\begin_layout Standard
Questo comportamento si può ottenere seguendo il flusso di richieste semplificat
o in Figura 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:sdp-malformed-continuation-state-workflow"

\end_inset

.
\end_layout

\begin_layout Standard
\align center
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{sequencediagram}
\end_layout

\begin_layout Plain Layout

	
\backslash
renewcommand
\backslash
unitfactor{0.75}
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	
\backslash
newthread{client}{SDP Client}
\end_layout

\begin_layout Plain Layout

	
\backslash
newinst[6]{server}{SDP Server}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	
\backslash
begin{call}{client}{
\backslash
small ServiceSearchRequest(UUID=
\backslash
(0
\backslash
)xDEAD)}{server}{
\backslash
small ServiceSearchResponse 
\backslash
((1/N)
\backslash
) + CS 
\backslash
((1)
\backslash
)}
\backslash
end{call}
\end_layout

\begin_layout Plain Layout

	
\backslash
begin{call}{client}{
\backslash
small ServiceSearchRequest(UUID=
\backslash
(0
\backslash
)xBEEF) + CS 
\backslash
((1)
\backslash
)}{server}{
\backslash
small ServiceSearchResponse 
\backslash
((2/N)
\backslash
) + CS 
\backslash
((2)
\backslash
)}
\backslash
end{call}
\end_layout

\begin_layout Plain Layout

	
\backslash
begin{call}{client}{
\backslash
dots}{server}{
\backslash
dots}
\backslash
end{call}
\end_layout

\begin_layout Plain Layout

	
\backslash
begin{call}{client}{
\backslash
small ServiceSearchRequest(UUID=
\backslash
(0
\backslash
)xBEEF) + CS 
\backslash
((i)
\backslash
)}{server}{
\backslash
small ServiceSearchResponse 
\backslash
((2/N)
\backslash
) + CS 
\backslash
((2)
\backslash
)}
\backslash
end{call}
\end_layout

\begin_layout Plain Layout

	
\backslash
begin{call}{client}{
\backslash
dots}{server}{
\backslash
dots}
\backslash
end{call}
\end_layout

\begin_layout Plain Layout

	
\backslash
begin{call}{client}{
\backslash
small ServiceSearchRequest(UUID=
\backslash
(0
\backslash
)xBEEF) + CS 
\backslash
((N)
\backslash
)}{server}{
\backslash
small ServiceSearchResponse 
\backslash
((N/N)
\backslash
)}
\backslash
end{call}
\end_layout

\begin_layout Plain Layout


\backslash
end{sequencediagram}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:sdp-malformed-continuation-state-workflow"

\end_inset

Workflow malformato di una comunicazione SDP con 
\emph on
continuation state
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Quello che permette l'
\emph on
underflow
\emph default
 è in particolare la scelta dei due servizi da interrogare.
 Più in dettaglio i passi da seguire sono:
\end_layout

\begin_layout Enumerate
Il client (attaccante) effettuata una richiesta SDP per un servizio con
 
\begin_inset Formula $\text{UUID}=0\text{xDEAD}$
\end_inset

.
\end_layout

\begin_layout Enumerate
Il server riceve la richiesta e genera una risposta contenente un 
\emph on
continuation state
\emph default
.
 La dimensione di questa risposta è definita dal valore di 
\begin_inset Flex CT - acronym
status collapsed

\begin_layout Plain Layout

MTU
\end_layout

\end_inset

 impostato dal client durante la connessione; in questo modo l'attaccante
 può controllare la dimensione dei frammenti restituiti.
\end_layout

\begin_layout Enumerate
Il client effettua una seconda richiesta SDP per un servizio con 
\begin_inset Formula $\text{UUID}=0\text{xBEEF}$
\end_inset

 apponendo alla richiesta il 
\emph on
continuation state
\emph default
 ricevuto dalla risposta precedente riferita al servizio con 
\begin_inset Formula $\text{UUID}=0\text{xDEAD}$
\end_inset

.
 Nella scelta dei due UUID è importante che il servizio interrogato per
 primo restituisca un numero di risposte superiore a quelle restituite dal
 secondo servizio scelto.
\end_layout

\begin_layout Enumerate
Il server riceve la richiesta ed effettua la validazione del campo 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

cont_offset
\end_layout

\end_inset

 che passerà senza problemi in quanto ricevuto direttamente dal server alla
 richiesta precedente.
\end_layout

\begin_layout Enumerate
A causa del fatto che il valore di 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

num_rsp_handles
\end_layout

\end_inset

 del servizio 
\emph on
con 
\emph default

\begin_inset Formula $\text{UUID}=0\text{xBEEF}$
\end_inset

 è minore di quello del servizio con 
\begin_inset Formula $\text{UUID}=0\text{xDEAD}$
\end_inset

, si otterrà l'
\emph on
underflow
\emph default
 sperato.
\begin_inset Newline newline
\end_inset

L'estratto di codice precedente si aspetterà di dover inviare una risposta
 molto grande (fino a 
\begin_inset Formula $64$
\end_inset

KB) e il codice seguente copierà tanti byte quanti ne entrano in un pacchetto
 di risposta 
\series bold
a partire dal precedente valore di offset
\series default
.
\begin_inset Newline newline
\end_inset


\begin_inset listings
lstparams "language={C++},tabsize=4"
inline false
status open

\begin_layout Plain Layout

for (xx = cont_offset; xx < cont_offset + cur_handles; xx++)
\end_layout

\begin_layout Plain Layout

	UINT32_TO_BE_STREAM(p_rsp, rsp_handles[xx]);
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Da questo punto in poi l'attaccante può ripetere la stessa richiesta al
 servizio con 
\begin_inset Formula $\text{UUID}=0\text{xBEEF}$
\end_inset

 apponendo il valore di 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

cont_offset
\end_layout

\end_inset

 ricevuto dal server alla richiesta precedente, continuando così a leggere
 byte nello stack fino a consumare il numero totale di frammenti specificato
 in 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

num_rsp_handles
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
I dati ottenuti in questo modo potenzialmente potrebbero contenere chiavi
 di cifratura, puntatori a dati o a codice, o altri dati che possono essere
 utilizzati congiuntamente ad altre vulnerabilità per bypassare alcuni meccanism
i di mitigazione messi a disposizione dal sistema operativo come l'
\begin_inset Flex CT - acronym
status collapsed

\begin_layout Plain Layout

ASLR
\end_layout

\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Misura di protezione che consiste nel rendere (parzialmente) casuale l'indirizzo
 delle funzioni di libreria e delle più importanti aree di memoria.
 In questo modo un attacco che cerca di eseguire codice malevolo su un computer
 è costretto a cercare gli indirizzi del codice e dei dati che gli servono
 prima di poterli usare.
\end_layout

\end_inset

.
 Per ultima, ma non meno importante, è anche la possibilità di creare un
 disservizio facendo si che il puntatore ai dati da leggere per costruire
 la risposta SDP punti ad un'area riservata del sistema operativo.
 L'accesso a queste aree di memoria, infatti, portano generalmente al riavvio
 improvviso del dispositivo.
\end_layout

\begin_layout Section
Andorid RCE (CVE-2017-0781)
\end_layout

\begin_layout Standard
\begin_inset CommandInset citation
LatexCommand nocite
key "blueborne_android_rce_white_paper"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
endgroup
\end_layout

\end_inset


\end_layout

\end_body
\end_document
