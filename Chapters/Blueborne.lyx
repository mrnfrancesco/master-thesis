#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass classicthesis
\use_default_options true
\maintain_unincluded_children false
\language italian
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine natbib
\cite_engine_type numerical
\biblio_style plainnat
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 2
\tocdepth 2
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begingroup
\end_layout

\begin_layout Plain Layout


\backslash
let
\backslash
clearpage
\backslash
relax
\end_layout

\begin_layout Plain Layout


\backslash
let
\backslash
cleardoublepage
\backslash
relax
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align right

\shape slanted
TODO
\begin_inset Newline newline
\end_inset


\shape default
 
\begin_inset VSpace medskip
\end_inset

 — 
\series bold
TODO
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Chapter
BlueBorne
\begin_inset CommandInset label
LatexCommand label
name "ch:blueborne"

\end_inset


\end_layout

\begin_layout Section
Analisi della superficie d'attacco Bluetooth
\end_layout

\begin_layout Standard
In un certo senso lo stack Bluetooth è l'equivalente dello stack TCP/IP,
 ma per comunicazioni Bluetooth; infatti a differenza di altri protocolli
 di comunicazione come Ethernet e WiFi, il Bluetooth non fa affidamento
 sullo stack TCP/IP per i protocolli applicativi di alto livello.
 Piuttosto sono stati definiti una gran varietà di protocolli e applicazioni
 a partire dal livello fisico fino al livello applicativo che nel complesso
 rappresentano lo stack Bluetooth (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:bluetooth-stack"

\end_inset

).
\end_layout

\begin_layout Standard
\align center
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename /home/mrnfrancesco/git/master-thesis/gfx/bluetooth-stack.png
	display false
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:bluetooth-stack"

\end_inset


\size footnotesize
Architettura dello stack Bluetooth
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
I livelli più bassi dello stack (livello fisico e di collegamento) sono
 implementati nei chip Bluetooth.
 Questi chip comunicano con un 
\emph on
host
\emph default
, che è il sistema operativo del dispositivo, tramite il protocollo 
\begin_inset Flex CT - acronym
status open

\begin_layout Plain Layout

HCI
\end_layout

\end_inset

.
 Tutti i protocolli al di sopra di questo livello (L2CAP, AMP, SMP, SDP
 e RFCOMM) sono invece implementati direttamente dall'host.
 A differenza dei driver degli adattatori Bluetooth che implementano diverse
 versioni dello stack per ogni hardware, i moderni sistemi operativi hanno
 una sola implementazione dello stack.
 Questo significa che ogni vulnerabilità che viene trovata in uno stack
 automaticamente affligge tutti i dispositivi su cui gira lo specifico sistema
 operativo che implementa quello stack.
\end_layout

\begin_layout Standard
\align center
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename /home/mrnfrancesco/git/master-thesis/gfx/bluetooth-stack-blocks-and-vulnerabilities.png
	display false
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:bluetooth-stack-blocks-and-vulnerabilities"

\end_inset


\size footnotesize
Blocchi fondamentali dello stack Bluetooth e vulnerabilità scoperte con
 BlueBorne
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
In Figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:bluetooth-stack-blocks-and-vulnerabilities"

\end_inset

 vengono mostrati i blocchi fondamentali dello stack Bluetooth evidenziando
 quelli dove risiedono le vulnerabilità di BlueBorne per i diversi sistemi
 operativi.
\end_layout

\begin_layout Section
Service Discovery Protocol
\end_layout

\begin_layout Standard
\begin_inset CommandInset citation
LatexCommand nocite
key "blueborne_white_paper"

\end_inset


\end_layout

\begin_layout Standard
Il 
\begin_inset Flex CT - acronym
status collapsed

\begin_layout Plain Layout

SDP
\end_layout

\end_inset

 è uno degli strati che fanno parte del core delle specifiche Bluetooth,
 quindi è presente in tutte le sue implementazioni.
 Il suo scopo è quello di permettere ai dispositivi che lo richiedono di
 scoprire i vari servizi e le applicazioni che il dispositivo interrogato
 supporta.
 SDP è inoltre responsabile di tradurre gli 
\begin_inset Flex CT - acronym
status collapsed

\begin_layout Plain Layout

UUID
\end_layout

\end_inset

 dei servizi Bluetooth in 
\begin_inset Flex CT - acronym
status collapsed

\begin_layout Plain Layout

PSM
\end_layout

\end_inset

 (l'equivalente L2CAP del numero di porta).
 Il valore PSM ottenuto viene poi usato per creare una connessione L2CAP
 al servizio associato.
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
Per scoprire i servizi esposti da un dispositivo, un client invia una richiesta
 SDP e riceve una risposta SDP eventualmente frammentata tramite un meccanismo
 proprio del livello SDP chiamato 
\emph on

\begin_inset Quotes eld
\end_inset

SDP Continuation
\begin_inset Quotes erd
\end_inset


\emph default
.
\end_layout

\begin_layout Standard
Il workflow di una comunicazione SDP tra client e server (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:sdp-continuation-state-workflow"

\end_inset

) è il seguente:
\end_layout

\begin_layout Enumerate
Un client invia una richiesta SDP.
\end_layout

\begin_layout Enumerate
Se la risposta eccede la 
\begin_inset Flex CT - acronym
status collapsed

\begin_layout Plain Layout

MTU
\end_layout

\end_inset

 della connessione L2CAP sottostante verrà inviato solo un frammento della
 risposta SDP seguita dalla struttura 
\begin_inset Flex CT - acronym
status collapsed

\begin_layout Plain Layout

CS
\end_layout

\end_inset

 che permette al client di richiedere il frammento successivo.
\end_layout

\begin_layout Enumerate
Per ricevere i restanti frammenti della risposta il client dovrà inviare
 di nuovo 
\series bold
la stessa richiesta
\series default
 seguita dal 
\emph on
Continuation State
\emph default
 ricevuto nell'ultima risposta SDP (questo tipo di richiesta viene chiamata
 
\emph on
continuation request
\emph default
).
\end_layout

\begin_layout Enumerate
Il server SDP invierà al client il frammento della risposta successivo a
 quello indicato nel 
\emph on
Continuation State
\emph default
.
\end_layout

\begin_layout Enumerate
Si ripete il procedimento dal punto 
\begin_inset Formula $3$
\end_inset

 finché tutti i frammenti della risposta non vengono inviati.
\end_layout

\begin_layout Standard
\align center
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{sequencediagram}
\end_layout

\begin_layout Plain Layout

	
\backslash
renewcommand
\backslash
unitfactor{0.75}
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	
\backslash
newthread{client}{SDP Client}
\end_layout

\begin_layout Plain Layout

	
\backslash
newinst[6]{server}{SDP Server}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	
\backslash
begin{call}{client}{
\backslash
small Richiesta}{server}{
\backslash
small Risposta 
\backslash
((1/N)
\backslash
) + CS 
\backslash
((1)
\backslash
)}
\backslash
end{call}
\end_layout

\begin_layout Plain Layout

	
\backslash
begin{call}{client}{
\backslash
small Richiesta + CS 
\backslash
((1)
\backslash
)}{server}{
\backslash
small Risposta 
\backslash
((2/N)
\backslash
) + CS 
\backslash
((2)
\backslash
)}
\backslash
end{call}
\end_layout

\begin_layout Plain Layout

	
\backslash
begin{call}{client}{
\backslash
dots}{server}{
\backslash
dots}
\backslash
end{call}
\end_layout

\begin_layout Plain Layout

	
\backslash
begin{call}{client}{
\backslash
small Richiesta + CS 
\backslash
((i)
\backslash
)}{server}{
\backslash
small Risposta 
\backslash
((i/N)
\backslash
) + CS 
\backslash
((i)
\backslash
)}
\backslash
end{call}
\end_layout

\begin_layout Plain Layout

	
\backslash
begin{call}{client}{
\backslash
dots}{server}{
\backslash
dots}
\backslash
end{call}
\end_layout

\begin_layout Plain Layout

	
\backslash
begin{call}{client}{
\backslash
small Richiesta + CS 
\backslash
((N)
\backslash
)}{server}{
\backslash
small Risposta 
\backslash
((N/N)
\backslash
)}
\backslash
end{call}
\end_layout

\begin_layout Plain Layout


\backslash
end{sequencediagram}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:sdp-continuation-state-workflow"

\end_inset


\size footnotesize
Workflow di una comunicazione SDP con 
\emph on
continuation state
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Le specifiche del meccanismo di frammentazione del livello SDP lasciano
 piena libertà agli sviluppatori circa la struttura del 
\emph on
Continuation State
\emph default
:
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
\align center

\emph on
\begin_inset Quotes eld
\end_inset

Il formato dell'informazione di continuazione non è standardizzato tra i
 server SDP.
 Ogni parametro del continuation state ha significato solo per il server
 SDP che lo ha generato.
\begin_inset Quotes erd
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Specifiche Bluetooth v5.0, Vol 3, Parte B, pagina 1926
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
Questa decisione è piuttosto singolare in quanto il 
\emph on
Continuation State
\emph default
 non è utilizzato in alcun modo dal client, ma il suo scopo è quello di
 essere utilizzato internamente dal server.
 Il motivo di ciò potrebbe essere quello di non sovraccaricare il server
 con il compito di mantenere in memoria lo stato delle richieste tra i vari
 client con cui è in corso una comunicazione.
 Nonostante questo abbia una logica, non viene presa in considerazione la
 possibilità che il client abusi di questo comportamento ad esempio inviando
 un 
\emph on
Continuation State
\emph default
 malformato, diverso da quello inviato dal server.
 È proprio questo tipo di azione che ha portato alla scoperta della vulnerabilit
à di tipo 
\emph on
Information Exposure
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Divulgazione intenzionale o non intenzionale di informazioni a un attore
 che non è esplicitamente autorizzato ad avere accesso a quell'informazione
\end_layout

\end_inset

 
\emph default
(
\begin_inset CommandInset href
LatexCommand href
name "CWE-200"
target "http://cwe.mitre.org/data/definitions/200.html"

\end_inset

) dell'implementazione dello stack Bluetooth di Android analizzata in dettaglio
 a seguire.
\end_layout

\begin_layout Subsection
Android Information Leak - CVE-2017-0785
\end_layout

\begin_layout Standard
La struttura del 
\emph on
Continuation State
\emph default
 utilizzata nell'implementazione Android dello stack Bluetooth è la seguente:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language={C++},showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout

typedef struct { 
\end_layout

\begin_layout Plain Layout

	uint16_t cont_offset;
\end_layout

\begin_layout Plain Layout

} sdp_cont_state_t;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In questo caso la struttura presenta solamente un offset di 
\begin_inset Formula $16$
\end_inset

 bit che indica quale frammento inviare alla prossima richiesta SDP.
\end_layout

\begin_layout Standard
La funzione che gestisce tutte le richieste SDP si trova in 
\begin_inset listings
lstparams "tabsize=4"
inline true
status open

\begin_layout Plain Layout

/stack/sdp/sdp_server.cc
\end_layout

\end_inset

 ed ha la seguente firma:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline false
status open

\begin_layout Plain Layout

void sdp_server_handle_client_req (tCONN_CB * p_ccb, BT_HDR * p_msg);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Come indicato nella documentazione, la funzione riceve tutti i dati derivanti
 dal livello L2CAP e li passa alla funzione appropriata per la gestione.
 Un estratto del codice è il seguente:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline false
status open

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

/* The first byte in the message is the pdu type */
\end_layout

\begin_layout Plain Layout

pdu_id = *p_req++;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Extract the transaction number and parameter length */
\end_layout

\begin_layout Plain Layout

BE_STREAM_TO_UINT16(trans_num, p_req);
\end_layout

\begin_layout Plain Layout

BE_STREAM_TO_UINT16(param_len, p_req);
\end_layout

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

switch (pdu_id) {
\end_layout

\begin_layout Plain Layout

	case SDP_PDU_SERVICE_SEARCH_REQ:
\end_layout

\begin_layout Plain Layout

		process_service_search(p_ccb, trans_num, param_len, p_req, p_req_end);
\end_layout

\begin_layout Plain Layout

		break;
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Proseguendo nell'albero delle chiamate andiamo ad analizzare la funzione
 che si occupa di gestire le richieste di ricerca di servizi, particolari
 richieste utilizzate per sapere se e quali servizi il dispositivo supporta
 del tipo richiesto.
\end_layout

\begin_layout Standard
Dalle specifiche Bluetooth otteniamo il formato dei pacchetti di richiesta
 e risposta di questo tipo con e senza 
\emph on
Continuation State
\emph default
, illustrati rispettivamente in Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:sdp-request-packet-format"

\end_inset

 e Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:sdp-response-packet-format"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align left
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
colorbitbox}[3]{%
\end_layout

\begin_layout Plain Layout

	
\backslash
rlap{
\backslash
bitbox{#2}{
\backslash
color{#1}
\backslash
rule{
\backslash
width}{
\backslash
height}}}%
\end_layout

\begin_layout Plain Layout

	
\backslash
bitbox{#2}{#3}}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{bytefield}[%
\end_layout

\begin_layout Plain Layout

	boxformatting={
\backslash
centering
\backslash
itshape},
\end_layout

\begin_layout Plain Layout

	bitwidth=1em]{32}
\end_layout

\begin_layout Plain Layout

	
\backslash
bitheader{0,7,8,12,13,15,16,23,24,28,29,31} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

	
\backslash
bitbox{8}{
\backslash
scriptsize PDU ID} &
\end_layout

\begin_layout Plain Layout

	
\backslash
bitbox{16}{
\backslash
scriptsize Transaction ID} &
\end_layout

\begin_layout Plain Layout

	
\backslash
colorbitbox{gray!15}{8}{
\backslash
scriptsize Parameter Length 
\backslash

\backslash
 
\backslash
tiny (Byte 
\backslash
(0
\backslash
))} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

	
\backslash
colorbitbox{gray!15}{8}{
\backslash
scriptsize Parameter Length 
\backslash

\backslash
 
\backslash
tiny (Byte 
\backslash
(1
\backslash
))} &
\end_layout

\begin_layout Plain Layout

	
\backslash
colorbitbox{orange!15}{5}{
\backslash
scriptsize Element Type} &
\end_layout

\begin_layout Plain Layout

	
\backslash
colorbitbox{orange!15}{3}{
\backslash
scriptsize Element Size} &
\end_layout

\begin_layout Plain Layout

	
\backslash
colorbitbox{orange!15}{8}{
\backslash
scriptsize Element Var Size} &
\end_layout

\begin_layout Plain Layout

	
\backslash
colorbitbox{green!15}{5}{
\backslash
scriptsize Value Type} &
\end_layout

\begin_layout Plain Layout

	
\backslash
colorbitbox{green!15}{3}{
\backslash
scriptsize Value Size} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

	
\backslash
colorbitbox{green!15}{16}{
\backslash
scriptsize Value} &
\end_layout

\begin_layout Plain Layout

	
\backslash
bitbox{16}{
\backslash
scriptsize Maximum Service Record Count} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

	
\backslash
colorbitbox{blue!15}{8}{
\backslash
scriptsize Continuation State Length 
\backslash

\backslash
 
\backslash
tiny (
\backslash
(=0x02
\backslash
))} &
\end_layout

\begin_layout Plain Layout

	
\backslash
colorbitbox{blue!15}{16}{
\backslash
scriptsize Continuation State Value} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
end{bytefield}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

~
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{bytefield}[%
\end_layout

\begin_layout Plain Layout

	boxformatting={
\backslash
centering
\backslash
itshape},
\end_layout

\begin_layout Plain Layout

	bitwidth=1em]{32}
\end_layout

\begin_layout Plain Layout

	
\backslash
bitheader{0,7,8,12,13,15,16,23,24,28,29,31} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

	
\backslash
bitbox{8}{
\backslash
scriptsize PDU ID} &
\end_layout

\begin_layout Plain Layout

	
\backslash
bitbox{16}{
\backslash
scriptsize Transaction ID} &
\end_layout

\begin_layout Plain Layout

	
\backslash
colorbitbox{gray!15}{8}{
\backslash
scriptsize Parameter Length 
\backslash

\backslash
 
\backslash
tiny (Byte 
\backslash
(0
\backslash
))} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

	
\backslash
colorbitbox{gray!15}{8}{
\backslash
scriptsize Parameter Length 
\backslash

\backslash
 
\backslash
tiny (Byte 
\backslash
(1
\backslash
))} &
\end_layout

\begin_layout Plain Layout

	
\backslash
colorbitbox{orange!15}{5}{
\backslash
scriptsize Element Type} &
\end_layout

\begin_layout Plain Layout

	
\backslash
colorbitbox{orange!15}{3}{
\backslash
scriptsize Element Size} &
\end_layout

\begin_layout Plain Layout

	
\backslash
colorbitbox{orange!15}{8}{
\backslash
scriptsize Element Var Size} &
\end_layout

\begin_layout Plain Layout

	
\backslash
colorbitbox{green!15}{5}{
\backslash
scriptsize Value Type} &
\end_layout

\begin_layout Plain Layout

	
\backslash
colorbitbox{green!15}{3}{
\backslash
scriptsize Value Size} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

	
\backslash
colorbitbox{green!15}{16}{
\backslash
scriptsize Value} &
\end_layout

\begin_layout Plain Layout

	
\backslash
bitbox{16}{
\backslash
scriptsize Maximum Service Record Count} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

	
\backslash
colorbitbox{blue!15}{8}{
\backslash
scriptsize No Continuation State 
\backslash

\backslash
 
\backslash
tiny (
\backslash
(=0x00
\backslash
))} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
end{bytefield}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:sdp-request-packet-format"

\end_inset


\size footnotesize
Formato del pacchetto di richiesta di una ricerca di servizi fatta tramite
 SDP rispettivamente con e senza 
\emph on
Continuation State
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align left
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:sdp-response-packet-format"

\end_inset


\size footnotesize
Formato del pacchetto di risposta di una ricerca di servizi fatta tramite
 SDP
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Nonostante il codice del server SDP di Android esegua alcune validazioni
 sul valore del campo 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

cont_offset
\end_layout

\end_inset

, in particolare sul numero totale di frammenti, è comunque possibile ottenere
 un 
\emph on
information leak.
\end_layout

\begin_layout Standard
La funzione vulnerabile è in 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

/stack/sdp/sdp_server.cc
\end_layout

\end_inset

:
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline false
status open

\begin_layout Plain Layout

static void process_service_search(
\end_layout

\begin_layout Plain Layout

	tCONN_CB* p_ccb,
\end_layout

\begin_layout Plain Layout

	uint16_t trans_num,
\end_layout

\begin_layout Plain Layout

	uint16_t param_len,
\end_layout

\begin_layout Plain Layout

	uint8_t* p_req,
\end_layout

\begin_layout Plain Layout

	UNUSED_ATTR uint8_t* p_req_end
\end_layout

\begin_layout Plain Layout

);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Il suo scopo è quello di gestire una richiesta di ricerca di un servizio
 da parte di un client SDP e costruire un messaggio di risposta da inviare
 indietro al client.
\end_layout

\begin_layout Standard
Andando ad analizzare più a fondo la sua implementazione poniamo la nostra
 attenzione sul seguente estratto:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language={C++},showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout

uint16_t cur_handles, rem_handles, cont_offset, num_rsp_handles;
\end_layout

\begin_layout Plain Layout

uint32_t rsp_handles[SDP_MAX_RECORDS] = {0};
\end_layout

\begin_layout Plain Layout

tSDP_RECORD* p_rec = NULL;
\end_layout

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

/* Check if this is a continuation request */
\end_layout

\begin_layout Plain Layout

if (*p_req) {
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

	if (cont_offset != p_ccb->cont_offset) {
\end_layout

\begin_layout Plain Layout

		sdpu_build_n_send_error(
\end_layout

\begin_layout Plain Layout

			p_ccb,
\end_layout

\begin_layout Plain Layout

			trans_num,
\end_layout

\begin_layout Plain Layout

			SDP_INVALID_CONT_STATE,
\end_layout

\begin_layout Plain Layout

			SDP_TEXT_BAD_CONT_INX
\end_layout

\begin_layout Plain Layout

		);
\end_layout

\begin_layout Plain Layout

		return;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	/* extract the remaining handles */
\end_layout

\begin_layout Plain Layout

	rem_handles = num_rsp_handles - cont_offset;
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

/* Calculate how many handles will fit in one PDU */
\end_layout

\begin_layout Plain Layout

cur_handles =
\end_layout

\begin_layout Plain Layout

	(uint16_t)((pccb->rem_mtu_size - SDP_MAX_SERVICE_RSPHDR_LEN) / 4);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if (rem_handles <= cur_handles)
\end_layout

\begin_layout Plain Layout

	cur_handles = rem_handles;
\end_layout

\begin_layout Plain Layout

else { /* Continuation is set */
\end_layout

\begin_layout Plain Layout

	p_ccb->cont_offset += cur_handles;
\end_layout

\begin_layout Plain Layout

	is_cont = true;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

for (xx = cont_offset; xx < cont_offset + cur_handles; xx++)
\end_layout

\begin_layout Plain Layout

	UINT32_TO_BE_STREAM(p_rsp, rsp_handles[xx]);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Come si può notare il codice mantiene una copia del valore di 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

cont_offset
\end_layout

\end_inset

 nell'oggetto 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

p_ccb
\end_layout

\end_inset

 che mantiene le informazioni di connessione, e controlla che il valore
 ricevuto sia uguale allo stato corrente della connessione; se i due valori
 differiscono la funzione termina segnalando l'errore.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline false
status open

\begin_layout Plain Layout

if (cont_offset != p_ccb->cont_offset) {
\end_layout

\begin_layout Plain Layout

	sdpu_build_n_send_error(...);
\end_layout

\begin_layout Plain Layout

	return;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In questo scenario non è possibile abusare di un valore di 
\emph on
continuation state
\emph default
 malformato che permetta di leggere zone di memoria arbitrarie.
 Tuttavia, come già visto in Fig.
 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:sdp-continuation-state-workflow"

\end_inset

, per il recupero dell'intera risposta il meccanismo di frammentazione del
 livello SDP si aspetta che la richiesta fatta del client sia sempre la
 stessa, mentre a variare è il valore del 
\emph on
continuation state
\emph default
.
 Possiamo notare come l'estratto di codice della funzione 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

process_service_search
\end_layout

\end_inset

 non abbia alcun controllo sulla consistenza dei parametri di due o più
 richieste successive; possiamo quindi sfruttare questo per portare il codice
 in uno stato inconsistente.
\end_layout

\begin_layout Standard
Il valore del numero di frammenti rimanenti da inviare al client non viene
 salvato nell'oggetto 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

p_ccb
\end_layout

\end_inset

 per essere validato alla ricezione di una nuova richiesta, ma è calcolato
 ad ogni invocazione della funzione eseguendo:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline false
status open

\begin_layout Plain Layout

rem_handles = num_rsp_handles - cont_offset;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
dove 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

num_rsp_handles
\end_layout

\end_inset

 rappresenta il numero totale di frammenti della risposta all'attuale richiesta
 SDP, mentre 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

cont_offset
\end_layout

\end_inset

, lo ricordiamo, è l'offset del frammento corrente da leggere.
\end_layout

\begin_layout Standard
La mancanza di questo controllo nasce dall'assunzione (errata) che due richieste
 successive facciano riferimento alla stessa risposta.
\end_layout

\begin_layout Standard
Se quindi potessimo sfruttare questa situazione in particolare portando
 il valore di 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

rem_handles
\end_layout

\end_inset

 ad essere maggiore del reale numero dei frammenti rimanenti, durante il
 
\emph on
loop
\emph default
 di lettura dei frammenti si andrebbero a leggere sequenze di byte nello
 stack oltre quelle che dovrebbero essere consentite.
\end_layout

\begin_layout Standard
L'
\emph on
information leak
\emph default
 può essere quindi ottenuto tramite underflow
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Si ha quando il risultato di un calcolo è un numero minore del valore minore
 rappresentabile.
 La conseguenza è quella di ottenere valori generalmente molto alti, vicini
 al massimo valore rappresentabile.
\end_layout

\end_inset

 della variabile 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

rem_handles
\end_layout

\end_inset

 ottenibile seguendo il flusso di richieste semplificato in Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:sdp-malformed-continuation-state-workflow"

\end_inset

.
\end_layout

\begin_layout Standard
\align center
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{sequencediagram}
\end_layout

\begin_layout Plain Layout

	
\backslash
renewcommand
\backslash
unitfactor{0.75}
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	
\backslash
newthread{client}{SDP Client}
\end_layout

\begin_layout Plain Layout

	
\backslash
newinst[6]{server}{SDP Server}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	
\backslash
begin{call}{client}{richiesta al servizio A}{server}{risposta (1/N) + continuati
on state (1)}
\backslash
end{call}
\end_layout

\begin_layout Plain Layout

	
\backslash
begin{call}{client}{richiesta al servizio B + continuation state (1)}{server}{ri
sposta (2/N) + continuation state (2)}
\backslash
end{call}
\end_layout

\begin_layout Plain Layout


\backslash
end{sequencediagram}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:sdp-malformed-continuation-state-workflow"

\end_inset


\size footnotesize
Workflow malformato di una comunicazione SDP con 
\emph on
continuation state
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Quello che permette l'
\emph on
underflow
\emph default
 è in particolare la scelta dei due servizi da interrogare.
 Più in dettaglio i passi da seguire sono:
\end_layout

\begin_layout Enumerate
Il client (attaccante) effettuata una richiesta SDP per un servizio 
\emph on
A
\emph default
.
\end_layout

\begin_layout Enumerate
Il server riceve la richiesta e genera una risposta contenente un 
\emph on
continuation state
\emph default
.
 La dimensione di questa risposta è definita dal valore di 
\begin_inset Flex CT - acronym
status collapsed

\begin_layout Plain Layout

MTU
\end_layout

\end_inset

 impostato dal client durante la connessione; in questo modo l'attaccante
 può controllare la dimensione dei frammenti restituiti.
\end_layout

\begin_layout Enumerate
Il client effettua una seconda richiesta SDP per un servizio 
\emph on
B
\emph default
 apponendo alla richiesta il 
\emph on
continuation state
\emph default
 ricevuto dalla risposta precedente riferita al servizio 
\emph on
A
\emph default
.
 È importante che il servizio 
\emph on
B
\emph default
 restituisca risposte di dimensione inferiore a quelle del servizio 
\emph on
A.
\end_layout

\begin_layout Enumerate
Il server riceve la richiesta ed effettua la validazione del campo 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

cont_offset
\end_layout

\end_inset

 che passerà senza problemi in quanto ricevuto direttamente dal server alla
 richiesta precedente.
\end_layout

\begin_layout Enumerate
A causa del fatto che il valore di 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

num_rsp_handles
\end_layout

\end_inset

 del servizio 
\emph on
B
\emph default
 è minore di quello del servizio 
\emph on
A
\emph default
, si otterrà l'
\emph on
underflow
\emph default
 sperato.
\end_layout

\begin_layout Enumerate
L'estratto di codice precedente si aspetterà di dover inviare una risposta
 molto grande (fino a 
\begin_inset Formula $64$
\end_inset

KB) e il codice seguente copierà tanti byte quanti specificati dal valore
 di 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

num_rsp_handles
\end_layout

\end_inset

 nel pacchetto di risposta
\begin_inset Newline newline
\end_inset


\begin_inset listings
lstparams "language={C++},tabsize=4"
inline false
status open

\begin_layout Plain Layout

for (xx = cont_offset; xx < cont_offset + cur_handles; xx++)
\end_layout

\begin_layout Plain Layout

	UINT32_TO_BE_STREAM(p_rsp, rsp_handles[xx]);
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Da questo punto in poi l'attaccante può ripetere la stessa richiesta al
 servizio 
\emph on
B
\emph default
 apponendo il valore di 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

cont_offset
\end_layout

\end_inset

 ricevuto dal server, continuando così a leggere byte nello stack fino a
 consumare il numero totale di frammenti specificato in 
\begin_inset listings
lstparams "language={C++},tabsize=4"
inline true
status open

\begin_layout Plain Layout

num_rsp_handles
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
I dati ottenuti in questo modo potenzialmente potrebbero contenere chiavi
 di cifratura, puntatori a dati o a codice, o altri dati che possono essere
 utilizzati congiuntamente ad altre vulnerabilità per bypassare alcuni meccanism
i di mitigazione messi a disposizione dal sistema operativo.
 Per ultima, ma non meno importante, è anche la possibilità di creare un
 disservizio facendo si che il puntatore ai dati da leggere per costruire
 la risposta SDP punti ad un'area riservata del sistema operativo.
 L'accesso a queste aree di memoria, infatti, portano generalmente al riavvio
 improvviso del dispositivo.
\end_layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Andorid Remote Command Execution - CVE-2017-0781
\end_layout

\begin_layout Standard
\begin_inset CommandInset citation
LatexCommand nocite
key "blueborne_android_rce_white_paper"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
endgroup
\end_layout

\end_inset


\end_layout

\end_body
\end_document
